<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />
    <meta name="generator" content="SciTE" />
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>
      Scintilla and SciTE
    </title>
  </head>
  <body bgcolor="#FFFFFF" text="#000000">
    <table bgcolor="#000000" width="100%" cellspacing="0" cellpadding="0" border="0">
      <tr>
        <td>
          <img src="SciTEIco.png" border="3" height="64" width="64" alt="Scintilla icon" />
        </td>
        <td>
          <a href="index.html" style="color:white;text-decoration:none"><font size="5">
          Scintilla</font></a>
        </td>
      </tr>
    </table>
    <h2>
       Scintilla Documentation
    </h2>
    <p>
       There is <a href="Design.html">an overview of the internal design of Scintilla</a>.
    </p>
    <p>
       <a href="ScintillaUsage.html">Some notes on using Scintilla</a>.
    </p>
    <p>
       <a href="Steps.html">How to use the Scintilla Edit Control on Windows</a>.
    </p>
    <p>
       <a href="http://www.scintilla.org/dmapp.zip">A simple sample using Scintilla from C++ on Windows</a>.
    </p>
    <p>
       <a href="http://www.scintilla.org/SciTry.vb">A simple sample using Scintilla from Visual Basic</a>.
    </p>
    <p>
       <a href="Lexer.txt">
       A detailed description of how to write a lexer, including a discussion of folding</a>.
    </p>
    <p>
       The <a href="SciCoding.html">coding style</a> used in Scintilla and SciTE
       are worth following if you want to contribute code to Scintilla but are not 
       compulsory.
    </p>
    <p>
       For now, the best way to work out how to develop using Scintilla is to see how SciTE uses
      it. SciTE exercises most of Scintilla's facilities.
    </p>
    <p>
       The Windows version of Scintilla is a Windows Control. As such, its primary programming
      interface is through Windows messages. Early versions of Scintilla emulated much of the 
      API defined by the standard Windows Edit and Richedit controls but those APIs are now 
      deprecated in favour of Scintilla's own, more consistent API. 
      In addition to messages performing the actions of a normal Edit control, Scintilla 
      allows control of syntax styling, markers, auto-completion and call tips.
    </p>
    The GTK+ version also uses messages in a similar way to the Windows version. This is different
    to normal GTK+ practice but made it easier to implement rapidly. 
    <p>
       The messages are (with wParam and lParam use)
    </p>
    <h3>
       Text retrieval and modification.
    </h3>
<pre>
SCI_GETTEXT(int length, char *text)
SCI_SETTEXT(&lt;unused&gt;, char *text)
SCI_GETLINE(int line, char *text)
SCI_REPLACESEL(&lt;unused&gt;, char *text)
SCI_SETREADONLY(bool readOnly)
SCI_GETREADONLY
SCI_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)
SCI_ADDTEXT(int length, char *s)
SCI_ADDSTYLEDTEXT(int length, cell *s)
SCI_INSERTTEXT(int pos, char *text)
SCI_CLEARALL
SCI_CLEARDOCUMENTSTYLE
SCI_GETCHARAT(int position)
SCI_GETSTYLEAT(int position)
SCI_GETSTYLEDTEXT(&lt;unused&gt;, TEXTRANGE *tr)
SCI_SETSTYLEBITS(int bits)
SCI_GETSTYLEBITS
</pre>
    <p>
	Each character in a Scintilla document is followed by an associated byte of styling
	information. The combination of a character byte and a style byte is called a cell. Style
	bytes are interpreted as a style index in the low 5 bits and as 3 individual bits of
	indicators. This allows 32 fundamental styles which is enough for most languages and three
	independent indicators so that, for example, syntax errors, deprecated names and bad
	indentation could all be displayed at once. Indicators may be displayed as simple underlines,
	squiggly underlines, a line of small 'T' shapes, a line of diagonal hatching or as strike-out. 
	Additional indicators such as blurred could be defined in the future. 
	The number of bits used for styles can be altered 
	with SCI_SETSTYLEBITS up to a maximum of 7 bits. 
	The remaining bits can be used for indicators.
    </p>
    <p>
	Positions within the Scintilla document refer to a character or the gap before that
	character. The caret exists between character positions and can be located from before the
	first character to after the last character. There are places where the caret can not go
	where two character bytes make up one character. This occurs when a DBCS character from a
	language like Japanese is included in the document or when line ends are marked with the CP/M
	standard of a carriage return followed by a line feed. The INVALID_POSITION constant (-1)
	represents an invalid position within the document.
    </p>
    <p>
	All lines of text in Scintilla are the same height, and this height is calculated from the
	largest font in any current style. This restriction is for performance as if lines differed
	in height then calculations involving positioning of text would require that text to be
	styled first.
    </p>
    <p>
	When wanting to completely restyle the document, for example after choosing a lexer,
	the SCI_CLEARDOCUMENTSTYLE can be used to clear all styling information and
	reset the folding state.
    </p>
<pre>
SCI_SETTARGETSTART(int pos) 
SCI_GETTARGETSTART 
SCI_SETTARGETEND(int pos)
SCI_GETTARGETEND
SCI_REPLACETARGET(int length, char *text)
SCI_REPLACETARGETRE(int length, char *text)
SCI_SETSEARCHFLAGS(int flags)
SCI_GETSEARCHFLAGS
SCI_SEARCHINTARGET(int length, string text)
</pre>
    <p>
	Using SCI_REPLACESEL, modifications cause scrolling and other visible changes
	which may take some time and cause unwanted display updates. If performing many 
	changes, such as a replace all command, the target can be used instead. 
	First set the range to be replaced. Then call SCI_REPLACETARGET or
	SCI_REPLACETARGETRE which returns the length taken by the replacement string. 
	The difference between SCI_REPLACETARGET and SCI_REPLACETARGETRE
	is that SCI_REPLACETARGETRE looks for \d patterns in the replacement text
	where d is a digit from 1 to 9 and substitutes in the values of tagged matches from the 
	most recent regular expression search.
    </p>
    <p>
	Searching can be performed within the target range with SCI_SEARCHINTARGET
	which uses a counted string to allow searching for null characters.
	Returns length of range or -1 for failure in which case target is not moved.
	The flags used by SCI_SEARCHINTARGET such as SCFIND_MATCHCASE,
	SCFIND_WHOLEWORD, SCFIND_WORDSTART, and SCFIND_REGEXP can 
	be set with SCI_SETSEARCHFLAGS. The SCI_SEARCHINTARGET call 
	may be simpler for some clients to use than SCI_FINDTEXT as that requires 
	using a pointer to a structure.
    </p>
<pre>
SCI_SETOVERTYPE
SCI_GETOVERTYPE
</pre>
    <p>
      SCI_GETOVERTYPE returns TRUE if overtyping is active otherwise 
      FALSE will be returned. Use SCI_GETOVERTYPE to set the overtype node.
    </p>
    <h3>
       Standard commands
    </h3>
<pre>
SCI_CUT
SCI_COPY
SCI_PASTE
SCI_CLEAR
SCI_CANPASTE
</pre>
    <h3>
       Error handling
    </h3>
<pre>
SCI_SETSTATUS
SCI_GETSTATUS
</pre>
    <p>
	If an error occurs, Scintilla may set an internal error number 
	which can be retrieved with SCI_GETSTATUS.
	Not currently used but will be in the future.
	To clear the error status call SCI_SETSTATUS(0).
    </p>
    <h3>
       Undo and Redo
    </h3>
<pre>
SCI_UNDO
SCI_CANUNDO
SCI_EMPTYUNDOBUFFER
SCI_REDO
SCI_CANREDO
SCI_SETUNDOCOLLECTION(bool collectUndo)
SCI_GETUNDOCOLLECTION
SCI_BEGINUNDOACTION
SCI_ENDUNDOACTION
</pre>
    <p>
	Scintilla has multiple level undo and redo. It will continue to collect undoable actions
	until memory runs out. Sequences of typing or deleting are compressed into single actions to
	make it easier to undo and redo at a sensible level of detail. Sequences of actions can be
	combined into actions that are undone as a unit. These sequences occur between
	SCI_BEGINUNDOACTION and SCI_ENDUNDOACTION messages. These sequences can be nested and only
	the top level sequences are undone as units.
    </p>
    <h3>
	Selection and information
    </h3>
<pre>
SCI_GETTEXTLENGTH
SCI_GETFIRSTVISIBLELINE
SCI_GETLINECOUNT
SCI_GETMODIFY
SCI_SETSEL(int start, int end)
SCI_GETSELTEXT(&lt;unused&gt;, char *text)
SCI_LINEFROMPOSITION(int position)
SCI_POSITIONFROMLINE(int line)
SCI_GETLINEENDPOSITION(int line)
SCI_LINELENGTH(int line)
SCI_POSITIONFROMPOINT(int x, int y)
SCI_POSITIONFROMPOINTCLOSE(int x, int y)
SCI_POINTXFROMPOSITION(&lt;unused&gt;, int position)
SCI_POINTYFROMPOSITION(&lt;unused&gt;, int position)
SCI_HIDESELECTION(bool hide)
SCI_GETLENGTH
SCI_SETCURRENTPOS(int position)
SCI_GETCURRENTPOS
SCI_SETANCHOR(int position)
SCI_GETANCHOR
SCI_SETSELECTIONSTART(int position)
SCI_GETSELECTIONSTART
SCI_SETSELECTIONEND(int position)
SCI_GETSELECTIONEND
SCI_SELECTALL
SCI_GOTOLINE(int line)
SCI_GOTOPOS(int position)
SCI_GETCURLINE(int textlen, char *text)
SCI_LINESONSCREEN
SCI_SELECTIONISRECTANGLE
SCI_MOVECARETINSIDEVIEW
SCI_WORDENDPOSITION(int position, bool onlyWordCharacters)
SCI_WORDSTARTPOSITION(int position, bool onlyWordCharacters)
</pre>
    <p>
	Scintilla maintains a selection which stretches between two points, the anchor and the
	current position.
    </p>
    <p>
	It is not possible to change the modified status as whether the document is modified is 
	determined by whether the undo position is at the save point.
    </p>
    <p>
	SCI_GETCURLINE retrieves the text of the line containing the caret and returns the position
	within the line of the caret.
    </p>
    <p>
	SCI_POSITIONFROMPOINT finds the closest character position to a point and
	SCI_POSITIONFROMPOINTCLOSE is similar but returns -1 if the point is 
	outside the window or not close to any characters.
    </p>
    <p>
	SCI_WORDENDPOSITION and SCI_WORDSTARTPOSITION can be used to find 
	the start and end of words using the same definition of words as used internally 
	within Scintilla.
    </p>
    <h3>
       Scrolling and automatic scrolling
    </h3>
<pre>
SCI_LINESCROLL(int column, int line)
SCI_SCROLLCARET
SCI_SETCARETPOLICY(int policy, int slop)
SCI_SETVISIBLEPOLICY(int policy, int slop)
SCI_SETHSCROLLBAR(bool visible)
SCI_GETHSCROLLBAR
SCI_GETXOFFSET
SCI_SETXOFFSET(int xoffset)
</pre>
    <p>
      SCI_SETCARETPOLICY can be set to a combination of the flags CARET_SLOP
      and CARET_STRICT to change the automatic vertical positioning of the view
      when ensuring a position is visible. If CARET_SLOP is on then the slop value 
      determines the number of line at top and bottom of the view where the caret should not
      go. If CARET_SLOP is off then the caret is centred within the view. When 
      CARET_STRICT is set then caret policy is rechecked even if the caret is completely 
      visible. If CARET_XEVEN is set then both the left and right margins are treated
      equally whereas if it is not set then displaying text to the left is preferred.
      CARET_XJUMPS causes the display to move in jumps and then stay still
      rather than in a series of smaller movements.
      SCI_SETVISIBLEPOLICY is a similar function that 
      determines how the vertical positioning is determined when 
      SCI_ENSUREVISIBLEENFORCEPOLICY is
      called. It takes VISIBLE_SLOP and VISIBLE_STRICT flags 
      for the policy parameter.
    </p>
    <p>
      The xoffset is the horizontal scroll position in pixels.
    </p>
    <h3>
       Searching
    </h3>
<pre>
SCI_FINDTEXT(int flags, TextToFind *ttf)
</pre>
    <p>
       Scintilla can find where a string is present in the document. 
       There are several option flags including a simple regular expression search.
       SCFIND_MATCHCASE indicates that a match only occurs with a 
       string that matches the case of the search string. 
       SCFIND_WHOLEWORD indicates that a match only occurs if the characters
       before and after are not word characters. SCFIND_WORDSTART
       indicates that a match only occurs if the character before is not a word character.
    </p>
    <p>
       SCFIND_REGEXP indicates that the search string should be interpreted as a regular 
       expression. Special characters interpreted are '.' for any character, '\(' and '\)' to tag
       parts of the match, '\1' .. '\9' to refer to tagged parts, '\&lt;' to match the start of a word,
       '\&gt;' to match the end of a word, 
       '\' as a quote character, '[' and ']'
       to indicate a set of characters, ^ within a set to complement the set, ^ outside a set
       to match the start of line, $ to match the end of line, * to match 0 or more times, 
       + to match 1 or more times
    </p>
    <p>
       See also SCI_SEARCHINTARGET.
    </p>
<pre>
SCI_SEARCHANCHOR
SCI_SEARCHNEXT(int flags, char *text)
SCI_SEARCHPREV(int flags, char *text)
</pre>
    <p>
	Relocatable search support. This allows
	multiple incremental interactive searches to be macro recorded
	while still setting the selection to found text so the find/select
	operation is self-contained.
    </p>
    <h3>
       Visible white space
    </h3>
<pre>
SCI_GETVIEWWS
SCI_SETVIEWWS(SCWS_INVISIBLE or SCWS_VISIBLEAFTERINDENT or
SCWS_VISIBLEALWAYS)
</pre>
    <p>
       White space can be made visible which may useful for languages in which whitespace is
      significant, such as Python. Space characters appear as small centred dots and tab characters
      as light arrows pointing to the right. With the SCWS_VISIBLEAFTERINDENT option, 
      white space used for indentation is invisible but after the first visible character, it is visible.
    </p>
    <h3>
       Cursor
    </h3>
<pre>
SCI_SETCURSOR
SCI_GETCURSOR
</pre>
    <p>
       The cursor is normally chosen in a context sensitive way so will be different over
       the margin than when over the text. When performing a slow action, a wait cursor
       can be shown by calling SCI_SETCURSOR(SC_CURSORWAIT) and restored 
       with SCI_SETCURSOR(SC_CURSORNORMAL).
    </p>
    <h3>
       Mouse Capture
    </h3>
<pre>
SCI_SETMOUSEDOWNCAPTURES(bool captures)
SCI_GETMOUSEDOWNCAPTURES
</pre>
    <p>
       When the mouse is pressed inside Scintilla, it is captured so future mouse movement
       events are sent to Scintilla. This behaviour may be turned off with 
       SCI_SETMOUSEDOWNCAPTURES(false).
    </p>
    <h3>
       Line endings
    </h3>
<pre>
SCI_GETEOLMODE
SCI_SETEOLMODE(SC_EOL_CRLF or SC_EOL_CR or SC_EOL_LF)
SCI_GETVIEWEOL
SCI_SETVIEWEOL(bool visible)
SCI_CONVERTEOLS(SC_EOL_CRLF or SC_EOL_CR or SC_EOL_LF)
</pre>
    <p>
       Scintilla can interpret any of the three major line end conventions, Macintosh (\r), Unix
      (\n) and CP/M / DOS / Windows (\r\n). When the user presses the Enter key, one of these line
      end strings is inserted into the buffer. The default is \r\n, but this can be changed with
      the SCI_SETEOLMODE message taking a an argument of SC_EOL_CRLF, SC_EOL_CR, or SC_EOL_LF. The
      SCI_GETEOLMODE message retrieves the current state.
    </p>
    <p>
       The characters that make up line ends can be made visible with the view EOL option. This
      looks similar to (CR), (LF), or (CR)(LF).
    </p>
    <p>
       All of the line ends in the document may be changed by calling SCI_CONVERTEOLS with the
      desired line ending.
    </p>
    <h3>
       Styling
    </h3>
<pre>
SCI_GETENDSTYLED
SCI_STARTSTYLING(int position, int mask)
SCI_SETSTYLING(int length, int style)
SCI_SETSTYLINGEX(int length, stylesequence *s)
SCI_SETLINESTATE(int line, int value)
SCI_GETLINESTATE(int line)
SCI_GETMAXLINESTATE
</pre>
    <p>
       Scintilla keeps a record of the last character that is likely to be styled correctly. This
      is moved forwards when characters after it are styled and moved backwards if changes are made
      to the text of the document before it. Before drawing text, this position is checked to see
      if any styling is needed and a notification message sent to the container if so. The
      container can send SCI_GETENDSTYLED to work out where it needs to start styling.
      Scintilla will always ask to style whole lines.
    </p>
    <p>
       To perform the actual styling, SCI_STARTSTYLING is sent with the position to start at and a
      mask indicating which bits of the style bytes can be set. The mask allows styling to occur
      over several passes, with, for example, basic styling done on an initial pass to ensure that
      the text of the code is seen quickly and correctly, and then a second slower pass, detecting
      syntax errors and using indicators to show where these are. After SCI_STARTSTYLING, multiple
      SCI_SETSTYLING messages are sent for each lexical entity to be styled.
    </p>
    <p>
      As well as the 8 bits of lexical state stored for each character there is also an integer stored 
      for each line. This can be used for longer lived parse states such as what the current scripting
      language is in an ASP page.
    </p>
    <p>
      The last line that has any line state can be found with SCI_GETMAXLINESTATE.
    </p>
       <h3>
       Style Definition
    </h3>
<pre>
SCI_STYLECLEARALL
SCI_STYLERESETDEFAULT
SCI_STYLESETFORE(int stylenumber, int colour)
SCI_STYLESETBACK(int stylenumber, int colour)
SCI_STYLESETBOLD(int stylenumber, bool bold)
SCI_STYLESETITALIC(int stylenumber, bool italic)
SCI_STYLESETSIZE(int stylenumber, int sizeinpoints)
SCI_STYLESETFONT(int stylenumber, char *fontname)
SCI_STYLESETEOLFILLED(int stylenumber, bool eolfilled)
SCI_STYLESETUNDERLINE(int stylenumber, bool underline)
SCI_STYLESETCHARACTERSET(int stylenumber, int charset)
SCI_STYLESETVISIBLE(int stylenumber, bool visible)
SCI_STYLESETCASE(int stylenumber, SC_CASE_MIXED or SC_CASE_UPPER or SC_CASE_LOWER)
SCI_STYLESETCHANGEABLE(int stylenumber, bool changeable)
</pre>
    <p>
	While the style setting messages mentioned above, change the style 
	numbers associated with	text, these messages define how those style 
	numbers are interpreted visually. The STYLE_DEFAULT style defines 
	the attributes that all styles will receive when SCI_STYLECLEARALL 
	is called. SCI_STYLERESETDEFAULT resets STYLE_DEFAULT to its state 
	when Scintilla was initialised.
    </p>
    <p>
	The EOLFILLED style uses the background colour at the end of the line
	to colour from the last character of the line to the right side of the window.
	This is useful when a document contains embedded sections in another 
	language such as HTML pages with embedded JavaScript. By setting both 
	the EOLFILLED style and a consistent background colour to all JavaScript 
	styles then JavaScript sections will be easily distinguished from HTML.
    </p>
    <p>
	SCI_STYLESETCHARACTERSET can set a style to use a different 
	character set than the default.
	For example, SCI_STYLESETCHARACTERSET(SCE_C_STRING, 
	SC_CHARSET_RUSSIAN) would ensure that strings in Russian would 
	display correctly. 
	This feature currently only works fully on Windows. 
    </p>
    <p>
      The character sets supported on Windows are:
SC_CHARSET_ANSI, SC_CHARSET_ARABIC, SC_CHARSET_BALTIC,
SC_CHARSET_CHINESEBIG5, SC_CHARSET_DEFAULT, 
SC_CHARSET_EASTEUROPE, SC_CHARSET_GB2312, SC_CHARSET_GREEK, 
SC_CHARSET_HANGUL, SC_CHARSET_HEBREW, SC_CHARSET_JOHAB, 
SC_CHARSET_MAC, SC_CHARSET_OEM, SC_CHARSET_SHIFTJIS, 
SC_CHARSET_SYMBOL, SC_CHARSET_THAI, SC_CHARSET_TURKISH, and
SC_CHARSET_VIETNAMESE. 
    </p>
    <p>
	The character sets supported on GTK+ are SC_CHARSET_ANSI,
	SC_CHARSET_EASTEUROPE, SC_CHARSET_GB2312, 
	SC_CHARSET_HANGUL, and SC_CHARSET_SHIFTJIS.
    </p>
    <p>
	As well as the 32 fundamental lexer styles, there are also some 
	predefined numbered styles starting at 32, STYLE_DEFAULT, 
	STYLE_LINENUMBER, STYLE_BRACELIGHT, STYLE_BRACEBAD, 
	STYLE_CONTROLCHAR, and STYLE_INDENTGUIDE. 
	These can be defined with the SCI_STYLESET* messages.
	To make it easier for client code to discover the range of styles 
	that are predefined, STYLE_LASTPREDEFINED is set to the style 
	number of the last predefined style.
    </p>
    <p>
	SCI_STYLESETCASE can force text to be displayed in upper case
	(SC_CASE_UPPER) or lower case (SC_CASE_LOWER).
    </p>
    <p>
	SCI_STYLESETCHANGEABLE is an experimental and incompletely 
	implemented style attribute. 
	The default setting is changeable but when turned off it makes text 
	read-only.
	Currently only stops caret from being within not-changeable text 
	and does not yet stop deleting a range that contains not-changeable 
	text.
    </p>
    <h3>
       Caret and Selection styles
    </h3>
<pre>
SCI_SETSELFORE(bool useSelectionForeColour, int colour)
SCI_SETSELBACK(bool useSelectionBackColour, int colour)
SCI_SETCARETFORE(int colour)
SCI_GETCARETFORE
SCI_SETCARETLINEVISIBLE(bool show)
SCI_GETCARETLINEVISIBLE
SCI_SETCARETLINEBACK(int colour)
SCI_GETCARETLINEBACK
SCI_SETCARETPERIOD(int milliseconds)
SCI_GETCARETPERIOD
SCI_SETCARETWIDTH(int pixels)
SCI_GETCARETWIDTH
SCI_SETCONTROLCHARSYMBOL(int symbol)
SCI_GETCONTROLCHARSYMBOL
</pre>
    <p>
	The selection is shown by changing the foreground and / or 
	background colours. 
	If one of these is not set then that attribute is not changed for 
	the selection. The default is to show the selection by changing the 
	background to light grey and leaving the foreground the same as 
	when it was not selected.
    </p>
    <p>
	The colour of the caret can be set with SCI_SETCARETFORE. 
	The background colour of the line containing the caret can be 
	changed to override the styles on that line with 
	SCI_GETCARETLINEVISIBLE	and the colour used set with 
	SCI_SETCARETLINEBACK. 
	The caret line background colour is overridden by any background 
	colour used to display markers.
	The rate at which the caret blinks can be set with 
	SCI_SETCARETPERIOD which determines the time in milliseconds that 
	the caret is visible or invisible before changing state. 
	Setting the period to 0 stops the caret	blinking. 
	The width of the caret can be set with SCI_SETCARETWIDTH to a value
	of 1, 2 or 3 pixels.
    </p>
    <p>
	SCI_SETCONTROLCHARSYMBOL specifies a character to use to indicate 
	control characters rather than having them displayed as mnemonics.
    </p>
    <h3>
       Margins
    </h3>
<pre>
SCI_SETMARGINLEFT(int width)
SCI_GETMARGINLEFT 
SCI_SETMARGINRIGHT(int width)
SCI_GETMARGINRIGHT
</pre>
    <p>
	Gets or sets the width of the blank margin on both sides of the 
	text. This defaults to one pixel on each side. 
    </p>
<pre>
SCI_SETMARGINTYPEN(int margin, SC_MARGIN_SYMBOL | SC_MARGIN_NUMBER)
SCI_GETMARGINTYPEN(int margin)
SCI_SETMARGINWIDTHN(int margin, int pixelwidth)
SCI_GETMARGINWIDTHN(int margin)
SCI_SETMARGINMASKN(int margin, int mask)
SCI_GETMARGINMASKN(int margin)
SCI_SETMARGINSENSITIVEN(int margin, bool sensitive)
SCI_GETMARGINSENSITIVEN(int margin)
</pre>
    <p>
	There may be up to three margins to the left of the text display. 
	Each margin may contain marker symbols and some may be set to 
	display line numbers (with SCI_SETMARGINTYPEN). The markers 
	displayed in each margin are set withSCI_SETMARGINMASKN. Any 
	markers not associated with a visible margin will be displayed as 
	changes in background colour in the text.
	A width in pixels can be set for each margin. Margins with a zero 
	width are ignored completely. Each margin may be made sensitive to 
	mouse clicks. A click in a sensitive margin will result in a 
	SCN_MARGINCLICK notification being sent to the container. Margins 
	that are not sensitive act as selection margins which make it 
	easy to select ranges of lines. 
    </p>
    <h3>
       Other settings
    </h3>
<pre>
SCI_SETUSEPALETTE(bool allowPaletteUse)
SCI_GETUSEPALETTE
</pre>
    <p>
	On 8 bit displays, which can only display a maximum of 256 colours, 
	the graphics environment mediates between the colour needs of 
	applications through the use of palettes. On GTK+, Scintilla always 
	uses a palette. On Windows, there are some problems with visual 
	flashing when switching between applications with palettes and it 
	is also necessary for the application containing the Scintilla 
	control to forward some messages to Scintilla for its palette code 
	to work.
    </p>
    <p>
	Because of these issues, the application must tell Scintilla to use 
	a palette. If Scintilla is not using a palette, then it will only 
	be able to display in those colours already available, which are 
	often the 20 Windows system colours.
    </p>
    <p>
	To see an example of how to enable palette support in Scintilla, 
	search the text of SciTE for WM_PALETTECHANGED, WM_QUERYNEWPALETTE 
	and SCI_SETUSEPALETTE.
    </p>
<pre>
SCI_SETBUFFEREDDRAW(bool isbuffered)
SCI_GETBUFFEREDDRAW
</pre>
    <p>
	Turns on or off buffered drawing. Buffered drawing draws each line 
	into a bitmap rather than directly to the screen and then copies 
	the bitmap to the screen. This avoids flickering although it does 
	take longer. The default is for drawing to be buffered.
    </p>
<pre>
SCI_SETTABWIDTH(int widthinchars)
SCI_GETTABWIDTH
SCI_SETINDENT(int widthinchars)
SCI_GETINDENT
SCI_SETUSETABS(bool usetabs)
SCI_GETUSETABS
SCI_SETTABINDENTS(bool tabIndents)
SCI_GETTABINDENTS
SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)
SCI_GETBACKSPACEUNINDENTS
</pre>
    <p>
	SCI_SETTABWIDTH sets the size of a tab as a multiple of the size 
	of a space character in the style of the first style definition. 
	SCI_SETINDENT sets the size of indentation in terms of characters. 
	SCI_SETUSETABS determines whether indentation should be created out 
	of a mixture of tabs and space or be based purely on spaces.
    </p>
    <p>
	Inside indentation whitespace the tab and backspace keys can be 
	made to indent and unindent rather than insert a tab character or 
	delete a character with the SCI_SETTABINDENTS and 
	SCI_GETBACKSPACEUNINDENTS functions.
    </p>
<pre>
SCI_SETLINEINDENTATION(int line, int indentation)
SCI_GETLINEINDENTATION(int line)
SCI_GETLINEINDENTPOSITION(int line)
SCI_GETCOLUMN(int position)
</pre>
    <p>
	The amount of indentation on a line can be discovered and set with 
	SCI_GETLINEINDENTATION and SCI_SETLINEINDENTATION. The indentation 
	is measured in character columns which correspond to the width of 
	space characters. 
	SCI_GETLINEINDENTPOSITION returns the position at the end of 
	indentation of a line. 
	SCI_GETCOLUMN returns the column number of a position within the 
	document taking the width of tabs into account.
    </p>
<pre>
SCI_SETCODEPAGE(int codepage)
SCI_GETCODEPAGE
</pre>
    <p>
	Scintilla has some very simple Japanese DBCS (and probably Chinese 
	and Korean) support. Use this message with argument set to the 
	code page number to set Scintilla to use code page information to 
	ensure double byte characters are treated as one character rather 
	than two. This also stops the caret from moving between the two 
	bytes in a double byte character. Call with argument set to zero 
	to disable DBCS support.
    </p>
    <p>
	On Windows, code page SC_CP_UTF8 (65001) sets Scintilla into 
	Unicode mode with the document treated as a sequence of characters 
	expressed in UTF-8. The text is converted to UCS-2 before being 
	drawn by the OS and can thus display Hebrew, Arabic, Cyrillic, and 
	Han characters. Languages which can use two characters stacked
	vertically in one horizontal space such as Thai will mostly work
	but there are som eissues where the characters are drawn 
	separately leading to visual glitches. Bidirectional text is not
	supported.
    </p>
<pre>
SCI_SETWORDCHARS(&lt;unused&gt;, char *chars)
</pre>
    <p>
	Scintilla has several functions that operate on words which are 
	defined to be contiguous sequences of characters from a particular 
	set of characters. This message defines which characters are 
	members of that set. If chars is null then the default set, 
	alphanumeric and '_', is used.
    </p>
<pre>
SCI_GRABFOCUS
SCI_SETFOCUS(bool focus)
SCI_GETFOCUS
</pre>
    <p>
	On GTK+, focus handling is more complicated than on Windows, 
	so Scintilla can be told with this message to grab the focus.
    </p>
    <p>
	The internal focus flag can be set with SCI_SETFOCUS.
	This is used by clients which have complex focus requirements such 
	as having their own window which gets the real focus but with the 
	need to indicate that Scintilla has the logical focus.
    </p>
    <h3>
       Brace highlighting
    </h3>
<pre>
SCI_BRACEHIGHLIGHT(int pos1, int pos2)
SCI_BRACEBADLIGHT(int pos1)
SCI_BRACEMATCH(int position, int maxReStyle)
</pre>
    <p>
	Up to two characters can be highlighted in a 'brace highlighting 
	style' which is defined as style number 34. If there is no matching 
	brace then the 'brace badlighting style', style	number 35, can be 
	used to show the brace that is unmatched. Using a position of
	INVALID_POSITION removes the highlight.
    </p>
    <p>
	The SCI_BRACEMATCH message finds a corresponding matching brace 
	given the position of one brace. The brace characters handled are 
	'(', ')', '[', ']', '{', '}', '&lt;', and '&gt;'. 
	A match only occurs if the style of the matching brace is the same 
	as the starting brace or the matching brace is beyond the end of 
	styling. Nested braces are handled correctly. The maxReStyle 
	parameter must currently be 0.
    </p>
    <h3>
       Indentation Guides
    </h3>
<pre>
SCI_SETINDENTATIONGUIDES(bool view)
SCI_GETINDENTATIONGUIDES
SCI_SETHIGHLIGHTGUIDE(int column)
SCI_GETHIGHLIGHTGUIDE
</pre>
    <p>
	Indentation guides are dotted vertical lines that appear within 
	indentation whitespace every indent size columns. They make it 
	easy to see which constructs line up especially when they extend 
	over multiple pages. Style 37 is used to specify the foreground and
	background colour of the indentation guides.
    </p>
    <p>
	When brace highlighting occurs, the indentation guide corresponding 
	to the braces may be highlighted with the brace highlighting style, 
	34.
    </p>
    <h3>
	Markers
    </h3>
<pre>
SCI_MARKERDEFINE(int markernumber, int markersymbols)
SCI_MARKERSETFORE(int markernumber, int colour)
SCI_MARKERSETBACK(int markernumber, int colour)
SCI_MARKERADD(int line, int markernumber)
SCI_MARKERDELETE(int line, int markernumber)
SCI_MARKERDELETEALL(int markernumber)
SCI_MARKERGET(int line)
SCI_MARKERNEXT(int lineStart, int markermask)
SCI_MARKERPREVIOUS(int lineStart, int markermask)
SCI_MARKERLINEFROMHANDLE(int handle)
SCI_MARKERDELETEHANDLE(int handle)
</pre>
    <p>
	Markers appear in the selection margin to the left of the text. 
	They are small geometric symbols often used in debuggers to 
	indicate breakpoints and the current line. If the selection margin 
	is set to zero width then the background colour of the whole line 
	is changed instead. There may be up to 32 marker symbols defined 
	and each line has a set of these markers associated with it. The 
	markers are drawn in the order of their numbers. Markers try to 
	move with their text by tracking where the start of their line 
	moves. When a line is deleted, its markers are combined, by an or 
	operation, with the markers of the previous line. The 
	SCI_MARKERDELETEALL removes markers of the given number from all 
	lines, and treats a parameter of -1 as meaning delete all markers 
	from all lines.<br />
	SCI_MARKERADD returns a marker handle number which may be used to 
	find out where a marker has moved to with the 
	SCI_MARKERLINEFROMHANDLE message. SCI_MARKERDELETEHANDLE can be 
	used to	delete a marker based upon its handle.
    </p>
    <p>
	SCI_MARKERGET retrieves the set of markers associated with a line. 
	SCI_MARKERNEXT and SCI_MARKERPREVIOUS can be used to efficiently 
	search for lines that contain markers. They return the next / 
	previous line with a set of markers that includes some of the bits 
	set in the markermask parameter.<br />
	The markermask is equal to a OR of (1 &lt;&lt; markernumber) for 
	each marker of the desired / retrieved set.
    </p>
    <p>
	The marker symbols currently available are SC_MARK_CIRCLE, 
	SC_MARK_ROUNDRECT, SC_MARK_ARROW, SC_MARK_SMALLRECT, 
	SC_MARK_SHORTARROW, SC_MARK_EMPTY, SC_MARK_ARROWDOWN, 
	SC_MARK_MINUS, SC_MARK_PLUS. 
	The SC_MARK_BACKGROUND marker changes the background colour
	of the line only.
	The SC_MARK_EMPTY symbol is invisible,
	allowing client code to track the movement of lines. 
	Characters can be used as markers by adding 
	the ASCII value of the character to SC_MARK_CHARACTER.
    </p>
    <p>
	There are also marker symbols available for the folding margin in a 
	flattened tree style:
	SC_MARK_BOXMINUS,
	SC_MARK_BOXMINUSCONNECTED,
	SC_MARK_BOXPLUS,
	SC_MARK_BOXPLUSCONNECTED,
	SC_MARK_CIRCLEMINUS,
	SC_MARK_CIRCLEMINUSCONNECTED,
	SC_MARK_CIRCLEPLUS,
	SC_MARK_CIRCLEPLUSCONNECTED,
	SC_MARK_LCORNER,
	SC_MARK_LCORNERCURVE,
	SC_MARK_TCORNER,
	SC_MARK_TCORNERCURVE, and
	SC_MARK_VLINE.
    </p>
    <p>
	The marker numbers SC_MARKNUM_FOLDER and SC_MARKNUM_FOLDEROPEN are
	used for showing that a fold is present and open or closed. Any 
	symbols may be assigned for this purpose although the 
	(SC_MARK_PLUS, SC_MARK_MINUS) pair or the (SC_MARK_ARROW, 
	SC_MARK_ARROWDOWN) pair are good choices.
	As well as these two, more assignments are needed for the 
	flattened tree style:
	SC_MARKNUM_FOLDEREND,
	SC_MARKNUM_FOLDERMIDTAIL,
	SC_MARKNUM_FOLDEROPENMID,
	SC_MARKNUM_FOLDERSUB, and
	SC_MARKNUM_FOLDERTAIL.
	The bits used for folding is specified by SC_MASK_FOLDERS which is 
	commonly used as an argument to SCI_SETMARGINMASKN when defining a 
	margin to be used for folding.
    </p>
    <h3>
       Indicators
    </h3>
<pre>
SCI_INDICSETSTYLE(int indicatornumber, int indicatorstyle)
SCI_INDICGETSTYLE(int indicatornumber)
SCI_INDICSETFORE(int indicatornumber, int colour)
SCI_INDICGETFORE(int indicatornumber)
</pre>
    <p>
	These messages allow setting the visual appearance of the three 
	(0, 1, and 2) available	indicators.
    </p>
    <p>
	The indicator styles currently available are INDIC_PLAIN, 
	INDIC_SQUIGGLE, INDIC_TT, INDIC_DIAGONAL, and INDIC_STRIKE.
    </p>
    <p>
	The indicators are set using SCI_STARTSTYLING with a INDICS_MASK 
	mask and SCI_SETSTYLING	with the values INDIC0_MASK, INDIC1_MASK 
	and INDIC2_MASK.
    </p>
    <h3>
       Autocompletion
    </h3>
<pre>
SCI_AUTOCSHOW(int lenEntered,char *list)
SCI_AUTOCCANCEL
SCI_AUTOCACTIVE
SCI_AUTOCPOSSTART
SCI_AUTOCCOMPLETE
SCI_AUTOCSTOPS(&lt;unused&gt;,char *chars)
SCI_AUTOCSETSEPARATOR(char separator)
SCI_AUTOCGETSEPARATOR
SCI_AUTOCSELECT(&lt;unused&gt;,char *stringtoselect)
SCI_AUTOCSETCANCELATSTART(bool cancel)
SCI_AUTOCGETCANCELATSTART
SCI_AUTOCSETFILLUPS(&lt;unused&gt;,char *chars)
SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)
SCI_AUTOCGETCHOOSESINGLE
SCI_AUTOCSETIGNORECASE(bool ignoreCase)
SCI_AUTOCGETIGNORECASE
SCI_AUTOCSETAUTOHIDE(bool autoHide)
SCI_AUTOCGETAUTOHIDE
SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)
SCI_AUTOCGETDROPRESTOFWORD
</pre>
    <p>
	Auto completion displays a list box based upon the users typing 
	showing likely identifiers. 
	The user chooses the currently selected item by pressing the tab character 
	or another character that is a member of the fillup character set defined
	with SCI_AUTOCSETFILLUPS.
    </p>
    <p>
	The SCI_AUTOCSHOW message causes this list to be displayed, with 
	its argument being a list of words separated by separator 
	characters. The initial separator character is a space but this can 
	be set  or got with SCI_AUTOCSETSEPARATOR and 
	SCI_AUTOCGETSEPARATOR.
	SCI_AUTOCPOSSTART returns the value of the current position when 
	SCI_AUTOCSHOW started display of the list.
	An entry can be selected SCI_AUTOCSELECT.
	The list of words should be in sorted order.
    </p>
    <p>
	The current selection can be triggered with the SCI_AUTOCCOMPLETE 
	message. This has the same effect as the tab key. When in 
	autocompletion mode, the list should disappear when the user
	types a character that can not be part of the autocompletion, 
	such as '.', '(' or '[' when typing an identifier. A set of 
	characters which will cancel autocompletion can be specified
	with the SCI_AUTOCSTOPS.
    </p>
    <p>
	If set to ignore case mode with SCI_AUTOCSETIGNORECASE, 
	then strings are matched after being converted to upper case.
	One result of this is that the list should be sorted with the punctuation 
	characters '[', '\', ']', '^', '_', and '`' sorted after letters.
    </p>
    <p>
	The default behaviour is for the list to be cancelled if the caret 
	moves before the location it was at when the list was displayed. 
	By calling SCI_AUTOCSETCANCELATSTART with a false argument, the 
	list is not cancelled until the caret moves before the first 
	character of the word being completed.
    </p>
    <p>
	The list will also be cancelled if there are no viable matches. 
	To avoid this behaviour call SCI_AUTOCSETAUTOHIDE with a false 
	argument.
    </p>
    <p>
	When an item is selected, any word characters following the caret are first
	erased if SCI_AUTOCSETDROPRESTOFWORD is used to set this mode.
    </p>
    <h3>
       User lists
    </h3>
<pre>
SCI_USERLISTSHOW(int listType,char *list)
</pre>
    <p>
	User lists are similar to auto completion but do not insert text 
	when an item is selected, instead notifying the container with a 
	SCN_USERLISTSELECTION. 
	The listType parameter is returned to the container and can be used 
	to differentiate between different types of list such as between a 
	list of	buffers and a list of keywords.
    </p>
    <h3>
       Calltips
    </h3>
<pre>
SCI_CALLTIPSHOW(int posStart, char *definition)
SCI_CALLTIPCANCEL
SCI_CALLTIPACTIVE
SCI_CALLTIPPOSSTART
SCI_CALLTIPSETHLT(int highlightstart, int highlightend)
SCI_CALLTIPSETBACK(int colour)
</pre>
    <p>
	Call tips are small windows displaying the arguments to a function 
	and are displayed after	the user has typed the name of the 
	function. As the user types values for each argument, the
	name of the argument currently being entered is highlighted.
    </p>
    <p>
	SCI_CALLTIPSHOW starts the process by displaying the calltip 
	window, with the definition argument containing the text to 
	display. SCI_CALLTIPPOSSTART returns the value of the current
	position when SCI_CALLTIPSHOW started display of the list. 
	SCI_CALLTIPSETHLT sets the region of the calltip text displayed in 
	a highlighted style. The background colour of calltips can
	be set with SCI_CALLTIPSETBACK with the default being white.
    </p>
    <h3>
       Keyboard Commands
    </h3>
<pre>
SCI_LINEDOWN
SCI_LINEDOWNEXTEND
SCI_LINEUP
SCI_LINEUPEXTEND
SCI_CHARLEFT
SCI_CHARLEFTEXTEND
SCI_CHARRIGHT
SCI_CHARRIGHTEXTEND
SCI_WORDLEFT
SCI_WORDLEFTEXTEND
SCI_WORDRIGHT
SCI_WORDRIGHTEXTEND
SCI_HOME
SCI_HOMEEXTEND
SCI_LINEEND
SCI_LINEENDEXTEND
SCI_DOCUMENTSTART
SCI_DOCUMENTSTARTEXTEND
SCI_DOCUMENTEND
SCI_DOCUMENTENDEXTEND
SCI_PAGEUP
SCI_PAGEUPEXTEND
SCI_PAGEDOWN
SCI_PAGEDOWNEXTEND
SCI_EDITTOGGLEOVERTYPE
SCI_CANCEL
SCI_DELETEBACK
SCI_DELETEBACKNOTLINE
SCI_TAB
SCI_BACKTAB
SCI_NEWLINE
SCI_FORMFEED
SCI_VCHOME
SCI_VCHOMEEXTEND
SCI_DELWORDLEFT
SCI_DELWORDRIGHT
SCI_DELLINELEFT
SCI_DELLINERIGHT
SCI_LINESCROLLDOWN
SCI_LINESCROLLUP
SCI_LINECUT
SCI_LINEDELETE
SCI_LINETRANSPOSE
SCI_LOWERCASE
SCI_UPPERCASE
SCI_WORDPARTLEFT
SCI_WORDPARTLEFTEXTEND
SCI_WORDPARTRIGHT
SCI_WORDPARTRIGHTEXTEND
</pre>
    <p>
	To allow the container application to perform any of the actions 
	available to the user with keyboard, all the keyboard actions are 
	messages. They do not take any parameters.
    </p>
    <p>
	These commands are also used when redefining the key bindings with 
	the SCI_ASSIGNCMDKEY message.
    </p>
    <p>
	The SCI_WORDPART* commands are used to move between word segments
	marked by capitalisation (aCamelCaseIdentifier) or underscores
	(an_under_bar_ident).
    </p>
    <h3>
       Key Bindings
    </h3>
<pre>
SCI_ASSIGNCMDKEY((short key,short modifiers), int message)
SCI_CLEARCMDKEY((short key,short modifiers))
SCI_CLEARALLCMDKEYS
SCI_NULL
</pre>
    <p>
	There is a default binding of keys to commands in Scintilla which 
	can be overridden with these messages. 
	To fit the parameters into a message, the first argument contains 
	the key	code in the low word and the key modifiers (possibly shift 
	and control) in the high word. The key code is a visible or control 
	character or a key from the SCK_* enumeration, 
	which contains SCK_ADD, SCK_BACK, SCK_DELETE, SCK_DIVIDE,
	SCK_DOWN, SCK_END, SCK_ESCAPE, SCK_HOME, SCK_INSERT,
	SCK_LEFT, SCK_NEXT, SCK_PRIOR, SCK_RETURN, SCK_RIGHT, 
	SCK_SUBTRACT, SCK_TAB, and SCK_UP.
	The modifiers are a combination of zero or more of
	SCMOD_ALT, SCMOD_CTRL, and SCMOD_SHIFT. 
	SCI_NULL does nothing and is the value assigned to keys that 
	perform no action.
    </p>
    <h3>
	Popup edit menu
    </h3>
<pre>
SCI_USEPOPUP
</pre>
    <p>
	Clicking the wrong button on the mouse pops up a short default 
	editing menu.
	This may be turned off with SCI_USEPOPUP(0).
    </p>
    <h3>
	Macro Recording
    </h3>
<pre>
SCI_STARTRECORD
SCI_STOPRECORD
</pre>
    <p>
	Starts and stops macro recording mode.
    </p>
    <h3>
	Printing
    </h3>
<pre>
SCI_FORMATRANGE
SCI_SETPRINTMAGNIFICATION(int magnification)
SCI_GETPRINTMAGNIFICATION
SCI_SETPRINTCOLOURMODE(int mode)
SCI_GETPRINTCOLOURMODE
</pre>
    <p>
	On Windows SCI_FORMATRANGE can be used to draw the text onto a 
	display context which can include a printer display context.
    </p>
    <p>
	To print at a different size than drawing on screen use 
	SCI_SETPRINTMAGNIFICATION with a value which is the number of 
	points to add to each style. -3 or -4 gives reasonable small print.
    </p>
    <p>
	If a black background is used on the screen then it is best to 
	invert the light value of all colours with 
	SCI_SETPRINTCOLOURMODE(SC_PRINT_INVERTLIGHT) when printing to give 
	a white background. 
	If intermediate tones are used on screen then black on white print 
	can be chosen with SCI_SETPRINTCOLOURMODE(SC_PRINT_BLACKONWHITE).
	Other options are the default, SC_PRINT_NORMAL, and 
	SC_PRINT_COLOURONWHITE and SC_PRINT_COLOURONWHITEDEFAULTBG.
    </p>
    <h3>
	Direct Access
    </h3>
<pre>
SCI_GETDIRECTFUNCTION
SCI_GETDIRECTPOINTER
</pre>
    <p>
	On Windows, the message passing scheme used to communicate between 
	the container and Scintilla is mediated by the operating system 
	SendMessage function which can lead to bad performance when 
	calling intensively. 
	To avoid this overhead a pointer to a message handling function 
	inside Scintilla can be retrieved with SCI_GETDIRECTFUNCTION. 
	The first argument to use when calling the returned function is the 
	value retrieved from SCI_GETDIRECTPOINTER. After that go the 
	message number, wParam, and lParam. 
    </p>
    <p>
	While faster, this direct calling will cause problems if performed 
	from a different thread to the native thread of the Scintilla 
	window in which case SendMessage should be used to synchronize with
	the window's thread.
    </p>
    <p>
	This feature also works on GTK+ but has no significant impact on 
	speed.
    </p>
    <h3>
	Multiple Views
    </h3>
<pre>
SCI_GETDOCPOINTER
SCI_SETDOCPOINTER(&lt;unused&gt;,document *pdoc)
SCI_CREATEDOCUMENT
SCI_ADDREFDOCUMENT(&lt;unused&gt;,document *pdoc)
SCI_RELEASEDOCUMENT(&lt;unused&gt;,document *pdoc)
</pre>
    <p>
	This is to allow simple split views of documents and so 
	applications may maintain multiple buffer which may be 
	individually selected into the editor. Each Scintilla has a pointer 
	to a used document. 
	Initially the used document is a default one created when the 
	Scintilla was created. 
	The SCI_GETDOCPOINTER call returns a pointer to the used document. 
	SCI_SETDOCPOINTER sets the used document. 
	SCI_SETDOCPOINTER(0) switches to a new empty document.
	Before closing down Scintilla make sure all document pointers 
	retrieved are released to avoid memory leaks. 
    </p>
    <p>
	A new document may be created by SCI_CREATEDOCUMENT which returns a 
	pointer to the document. This document is not selected into the 
	editor and starts with a reference count of 1. A document may be 
	released with SCI_RELEASEDOCUMENT and have its reference count 
	incremented with SCI_ADDREFDOCUMENT.
    </p>
    <h3>
	Folding
    </h3>
<pre>
SCI_VISIBLEFROMDOCLINE(int docLine)
SCI_DOCLINEFROMVISIBLE(int displayLine)
SCI_SETFOLDLEVEL(int line, int level)
SCI_SETFOLDFLAGS(int flags)
SCI_GETFOLDLEVEL(int line)
SCI_GETLASTCHILD(int line)
SCI_GETFOLDPARENT(int line)
SCI_SHOWLINES(int lineStart, int lineEnd)
SCI_HIDELINES(int lineStart, int lineEnd)
SCI_GETLINEVISIBLE(int line)
SCI_SETFOLDEXPANDED(int line)
SCI_GETFOLDEXPANDED(int line)
SCI_TOGGLEFOLD(int line)
SCI_ENSUREVISIBLE(int line)
SCI_ENSUREVISIBLEENFORCEPOLICY(int line)
</pre>
    <p>
	The fundamental operation in folding is making lines invisible or 
	visible. 
	Line visibility is a property of the view rather than the document 
	so each view may be displaying a different set of lines. 
	SCI_SHOWLINES and SCI_HIDELINES show or hide a range of lines. 
	SCI_GETLINEVISIBLE determines whether a line is visible. 
	When some lines are hidden, then a particular line in the document 
	may be displayed at a different position to its document position. 
	SCI_VISIBLEFROMDOCLINE and SCI_DOCLINEFROMVISIBLE map from 
	document line to display line and back.
    </p>
    <p>
	Generally the fold points of a document are based on the 
	hierarchical structure of the contents of the document. 
	In Python, the hierarchy is determined by indentation and in C++ 
	by brace characters. This hierarchy can be represented within a 
	Scintilla document object by attaching a numeric level to each 
	line. 
	The initial level of a file is SC_FOLDLEVELBASE to allow unsigned 
	arithmetic on levels. The SC_FOLDLEVELNUMBERMASK constant can be 
	used to mask out the other bits to reveal the fold level number.
	There are also two bit flags associated with each line. 
	SC_FOLDLEVELWHITEFLAG indicates that the line is blank and allows 
	it to be treated slightly different then its level may indicate. 
	For example, blank lines should generally not be fold points. 
	SC_FOLDLEVELHEADERFLAG indicates that the line is a header or fold 
	point.
    </p>
    <p>
	The hierarchy can be navigated just through SCI_GETFOLDLEVEL, but 
	it is often useful to find the parent of a line (SCI_GETFOLDPARENT) 
	or the line that is the last child of a line (SCI_GETLASTCHILD).
    </p>
    <p>
	Each fold point may be either expanded, displaying all its child 
	lines, or contracted, hiding all the child lines. This is per view 
	state and can be manipulated with SCI_SETFOLDEXPANDED and 
	SCI_GETFOLDEXPANDED. Using SCI_SETFOLDEXPANDED does not show or 
	hide any lines but only changes a state flag and the margin markers 
	that show the contraction state. SCI_TOGGLEFOLD performs the 
	expansion or contraction of a fold point in the manner normally 
	expected. 
    </p>
    <p>
	A hidden line may be hidden because more than one of its parent 
	lines is contracted. SCI_ENSUREVISIBLE travels up the fold 
	hierarchy, expanding any contracted folds until it reaches the top 
	level. The line will then be visible.
    </p>
    <p>
	The fold flags is a set of bit flags set with the SCI_SETFOLDFLAGS 
	message to determine where folding lines are drawn. 2 is draw above 
	if expanded, 4 is draw above if not expanded. 8 is draw below if 
	expanded and 16 is draw below if not expanded. 
	64 is display hexadecimal fold levels in line margin to aid debugging folding.
	This feature needs to be redesigned to be sensible.
    </p>
    <h3>
       Line Wrapping
    </h3>
<pre>
SCI_SETWRAPMODE(SC_WRAP_NONE or SC_WRAP_WORD)
SCI_GETWRAPMODE
</pre>
    <p>
	When the wrap mode is set to SC_WRAP_WORD lines wider than the 
	window width are continued on the following lines. Lines are 
	broken after space or tab characters or between runs of different
	styles. If this is not possible because a word in one style is 
	wider than the window then the break occurs before after the last 
	character that completely fits on the line.
	The horizontal scroll bar does not appear when wrap mode is on.
    </p>
<pre>
SCI_SETLAYOUTCACHE(SC_CACHE_NONE or SC_CACHE_CARET or SC_CACHE_PAGE or SC_CACHE_DOCUMENT)
SCI_GETLAYOUTCACHE
</pre>
    <p>
	Much of the time used by Scintilla is spent on laying out and drawing text.
	The same text layout calculations may be performed many times
	even when the data used in these calculations does not change. 
	To avoid these unnecessary calculations in some circumstances, the line
	layout cache can store the results of the calculations. 
	The cache in invalidated whenever the underlying data, such as the contents 
	or styling of the document changes.
	Caching the layout of the whole document has the most effect, making dynamic
	line wrap as much as 20 times faster but this requires 7 times the memory 
	required by the document contents.
    </p>
    <p>
	SC_CACHE_NONE performs no caching and is the default.
	SC_CACHE_CARET caches the layout information for the line containing the
	caret. 
	SC_CACHE_PAGE caches the layout of the visible lines and the caret
	line. 
	SC_CACHE_DOCUMENT caches the layout of the entire document.
    </p>
    <h3>
    	Zooming
    </h3>
<pre>
SCI_ZOOMIN
SCI_ZOOMOUT
SCI_SETZOOM
SCI_GETZOOM
</pre>
    <p>
	The text can be made larger and smaller by using SCI_ZOOMIN and 
	SCI_ZOOMOUT.
	The zoom level can be retrieved by SCI_GETZOOM and set by 
	SCI_SETZOOM. 
	The zoom factors may range from -10 to + 20 and is added to each 
	styles point size. The calculated point size never goes below 2.
    </p>
    <h3>
	Long Lines
    </h3>
<pre>
SCI_GETEDGECOLUMN 
SCI_SETEDGECOLUMN(int column)
SCI_GETEDGEMODE
SCI_SETEDGEMODE(int mode)
SCI_GETEDGECOLOUR 
SCI_SETEDGECOLOUR(int colour)
</pre>
    <p>
	This mechanism marks lines that are longer than a specified length 
	in one of two ways. A vertical line can be displayed at the 
	specified column number (EDGE_LINE) or characters after	that 
	column can be displayed with a specified background colour 
	(EDGE_BACKGROUND). The vertical line works well for monospaced 
	fonts but not for proportional fonts which should use 
	EDGE_BACKGROUND. The default is to not have any form of long line 
	marking (EDGE_NONE).
    </p>
    <h3>
    	Lexer
    </h3>
<pre>
SCI_SETLEXER(int lexer)
SCI_SETLEXERLANGUAGE(&lt;unused&gt;, char *name)
SCI_GETLEXER
SCI_COLOURISE(int start, int end)
SCI_SETPROPERTY(char *key, char *value)
SCI_SETKEYWORDS(int keywordset, char *keywordlist)
</pre>
    <p>
	If the SciLexer version of Scintilla is used, then lexing support 
	for some programming languages is included. A particular lexer may 
	be chosen from the SCLEX* enumeration and it is invoked 
	automatically to style the document as required. Lexers can also 
	be chosen by string name rather	than by integer ID.
	If the lexer is set to SCLEX_CONTAINER then the container is 
	notified to perform styling as is the case with the standard 
	Scintilla.DLL version. Styling may be requested for a range of the 
	document by using SCI_COLOURISE.
    </p>
    <p>
	Settings can be communicated to the lexers using SCI_SETPROPERTY. 
	Currently the "fold" property is defined for most of the lexers to 
	set the fold structure if set to "1". SCLEX_PYTHON understands 
	"tab.timmy.whinge.level" as a setting that determines how to 
	indicate bad indentation. Many languages style a set of keywords
	distinctly from other words. Some languages, such as HTML may 
	contain embedded languages, VBScript and Javascript are common for 
	HTML. SCI_SETKEYWORDS specifies the keywords separated by spaces. 
	For HTML, key word set is for HTML, 1 is for Javascript and 2 is 
	for VBScript.
    </p>
    <h3>
       Notifications
    </h3>
    <p>
	Notifications are sent (fired) from the Scintilla control to its 
	container when an event has occurred that may interest the 
	container. Notifications are sent using the WM_NOTIFY message on 
	Windows and the "notify" signal on GTK+ with a structure containing 
	information about the event.
    </p>
<pre>
SCN_STYLENEEDED(int endstyleneeded)
</pre>
    <p>
	Before displaying a page or printing, this message is sent to the 
	container. It is a good opportunity for the container to ensure 
	that syntax styling information for the visible text.
    </p>
<pre>
SCN_UPDATEUI
SCN_CHECKBRACE
</pre>
    <p>
	Either the text or styling of the document has changed or the 
	selection range has changed. Now would be a good time to update 
	any container UI elements that depend on document or view state. 
	Was previously called SCN_CHECKBRACE because a common use is to 
	check whether the caret is next to a brace and set highlights on 
	this brace and its corresponding matching brace.
    </p>
<pre>
SCN_CHARADDED(int charadded)
</pre>
    <p>
	Fired when the user types an ordinary text character (as opposed 
	to a command character)	which is entered into the text. 
	Can be used by the container to decide to display a call tip or 
	auto completion list.
    </p>
<pre>
SCN_POSCHANGED(int newPos)
</pre>
    <p>
       Fired when the user moves the cursor to a different position in the text.
      Can be used by the container to cancel some time consuming thread.
    </p>
<pre>
SCN_SAVEPOINTREACHED
SCN_SAVEPOINTLEFT
SCI_SETSAVEPOINT
</pre>
    <p>
	Sent to the container when the savepoint is entered or left, 
	allowing the container to display a dirty indicator and change its 
	menus. 
    </p>
    <p>
	The container tells Scintilla where the save point is by sending 
	the SCI_SETSAVEPOINT message.  This is usually done when the file 
	is saved or loaded.  As Scintilla performs undo and redo 
	operations, it will notify the container that it has entered or 
	left the save point, allowing the container to know if the file 
	should be considered dirty or not.
    </p>
<pre>
SCN_MODIFYATTEMPTRO
</pre>
    <p>
	When in read-only mode, this notification is sent to the container 
	should the user try to edit the document. This can be used to 
	check the document out of a version control system.
    </p>
<pre>
SCN_DOUBLECLICK
</pre>
    <p>
	Mouse button was double clicked in editor.
    </p>
<pre>
SCN_KEY
</pre>
    <p>
	Reports all keys pressed. Used on GTK+ because of some problems 
	with keyboard focus. Not sent by Windows version.
    </p>
<pre>
SCEN_SETFOCUS
SCEN_KILLFOCUS
</pre>
    <p>
	SCEN_SETFOCUS is fired when Scintilla receives focus and 
	SCEN_KILLFOCUS when it loses focus.
	These notifications are sent using the WM_COMMAND message on 
	Windows and the "Command" signal on GTK+ as this is the behaviour 
	of the standard edit control.
    </p>
<pre>
SCN_MODIFIED
SCEN_CHANGE
SCI_SETMODEVENTMASK(int eventmask)
SCI_GETMODEVENTMASK
</pre>
    <p>
	SCN_MODIFIED is fired when the document has been changed including 
	changes to both the text and styling. The notification structure 
	contains information about what changed, how the change occurred 
	and whether this changed the number of lines in the document. No 
	modifications may be performed while in a SCN_MODIFIED event.
    </p>
    <p>
	SCEN_CHANGE is fired when the text of the document has been changed 
	for any reason. This notification is sent using the WM_COMMAND 
	message on Windows and the "Command" signal on GTK+ as this is the 
	behaviour of the standard edit control.
    </p>
    <p>
	Both these notifications can be masked by the SCI_SETMODEVENTMASK 
	function which sets which notification types are sent to the 
	container. For example, a container may decide to see only
	notifications about changes to text and not styling changes by 
	calling SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT).
    </p>
    <p>
	The possible notification types are
	SC_MOD_INSERTTEXT,
	SC_MOD_DELETETEXT, 
	SC_MOD_CHANGESTYLE, 
	SC_MOD_CHANGEFOLD, 
	SC_PERFORMED_USER, 
	SC_PERFORMED_UNDO, 
	SC_PERFORMED_REDO, 
	SC_LASTSTEPINUNDOREDO, 
	SC_MOD_CHANGEMARKER, 
	SC_MOD_BEFOREINSERT, 
	SC_MOD_BEFOREDELETE, and 
	SC_MODEVENTMASKALL.
    </p>
<pre>
SCN_MACRORECORD
</pre>
    <p>
	Tells the container that an operation is being performed so that 
	the container may choose to record the fact if it is in a macro 
	recording mode.
    </p>
<pre>
SCN_MARGINCLICK
</pre>
    <p>
	Tells the container that the mouse was clicked inside a margin 
	marked sensitive. Can be used to perform folding or to place 
	breakpoints.
    </p>
<pre>
SCN_NEEDSHOWN
</pre>
    <p>
	Scintilla has determined that a range of lines that is currently 
	invisible should be made visible. 
	An example of where this may be needed is if the end of line of a 
	contracted fold point is deleted. This message is sent to the 
	container in case it wants to make the line visible in some 
	unusual way such as making the whole document visible. 
	Most containers will just ensure each line in the range is 
	visible by calling SCI_ENSUREVISIBLE.
    </p>
<pre>
SCN_PAINTED
</pre>
    <p>
	Painting has just been done. Useful when you want to update some 
	other widgets based on a change in Scintilla, but want to have the 
	paint occur first to appear more responsive.
    </p>
<pre>
SCN_USERLISTSELECTION
</pre>
    <p>
	User has selected an item in a user list. 
	The list type is available in wParam and the text chosen in text.
    </p>
<pre>
SCN_URIDROPPED
</pre>
    <p>
	Only on the GTK+ version. Indicates that the user has dragged a URI 
	such as	a file name or web address onto Scintilla. 
	The container could interpret this as a request to open the file.
    </p>
<pre>
SCN_DWELLSTART
SCN_DWELLEND
SCI_SETMOUSEDWELLTIME
SCI_GETMOUSEDWELLTIME
SC_TIME_FOREVER
</pre>
    <p>
	SCN_DWELLSTART is generated when the user hold the 
	mouse still in one spot for the dwell period. 
	SCN_DWELLEND is generated after a SCN_DWELLSTART
	and the mouse is moved or other activity such as key press
	indicates the dwell is over.
    </p>
    <p>
	The time the mouse must sit still, in milliseconds, to generate a 
	SCI_DWELLSTART.
	If set to SC_TIME_FOREVER, the default, no dwell events will be 
	generated.
    </p>
    <h3>
	Edit messages currently supported by Scintilla which will be 
	removed in the future.
    </h3>
<pre>
WM_GETTEXT(int length, char *text)
WM_SETTEXT(&lt;unused&gt;, char *text)
EM_GETLINE(int line, char *text)
EM_REPLACESEL(&lt;unused&gt;, char *text)
EM_SETREADONLY
EM_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)
WM_CUT
WM_COPY
WM_PASTE
WM_CLEAR
WM_UNDO
EM_CANUNDO
EM_EMPTYUNDOBUFFER
WM_GETTEXTLENGTH
EM_GETFIRSTVISIBLELINE
EM_GETLINECOUNT
EM_GETMODIFY
EM_SETMODIFY(bool ismodified)
EM_GETRECT(RECT *rect)
EM_GETSEL(int *start, int *end)
EM_EXGETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_SETSEL(int start, int end)
EM_EXSETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_GETSELTEXT(&lt;unused&gt;, char *text)
EM_LINEFROMCHAR(int position)
EM_EXLINEFROMCHAR(int position)
EM_LINEINDEX(int line)
EM_LINELENGTH(int position)
EM_SCROLL(int line)
EM_LINESCROLL(int column, int line)
EM_SCROLLCARET()
EM_CANPASTE
EM_CHARFROMPOS(&lt;unused&gt;, POINT *location)
EM_POSFROMCHAR(int position, POINT *location)
EM_SELECTIONTYPE
EM_HIDESELECTION(bool hide)
EM_FINDTEXT(int flags, FINDTEXTEX *ft)
EM_FINDTEXTEX(int flags, FINDTEXTEX *ft)
EM_GETMARGINS 
EM_SETMARGINS(EC_LEFTMARGIN or EC_RIGHTMARGIN or EC_USEFONTINFO, int val)
EM_FORMATRANGE
</pre>
    <h3>
       Edit messages never supported by Scintilla
    </h3>
<pre>
EM_GETWORDBREAKPROC EM_GETWORDBREAKPROCEX
EM_SETWORDBREAKPROC EM_SETWORDBREAKPROCEX
EM_GETWORDWRAPMODE EM_SETWORDWRAPMODE
EM_LIMITTEXT EM_EXLIMITTEXT
EM_SETRECT EM_SETRECTNP
EM_FMTLINES
EM_GETHANDLE EM_SETHANDLE
EM_GETPASSWORDCHAR EM_SETPASSWORDCHAR
EM_SETTABSTOPS
EM_FINDWORDBREAK
EM_GETCHARFORMAT EM_SETCHARFORMAT
EM_GETOLEINTERFACE EM_SETOLEINTERFACE
EM_SETOLECALLBACK
EM_GETPARAFORMAT EM_SETPARAFORMAT
EM_PASTESPECIAL
EM_REQUESTRESIZE
EM_GETBKGNDCOLOR EM_SETBKGNDCOLOR
EM_STREAMIN EM_STREAMOUT
EM_GETIMECOLOR EM_SETIMECOLOR
EM_GETIMEOPTIONS EM_SETIMEOPTIONS
EM_GETOPTIONS EM_SETOPTIONS
EM_GETPUNCTUATION EM_SETPUNCTUATION
EM_GETTHUMB
EM_GETEVENTMASK
EM_SETEVENTMASK
EM_DISPLAYBAND
EM_SETTARGETDEVICE
</pre>
    <p>
	Scintilla tries to be a superset of the standard windows Edit and 
	Richedit controls wherever that makes sense. As it is not 
	intended for use in a word processor, some edit messages can
	not be sensibly handled. Unsupported messages have no effect.
    </p>
    <h3>
	Building Scintilla
    </h3>
    <p>
	To build Scintilla or SciTE, see the README file present in both 
	the scintilla and scite directories. For Windows, GCC 2.95.3, 
	Borland C++ or Microsoft Visual C++ can be used for building. 
	For GTK+, GCC 2.95.2 should be used. Only GTK+ 1.2x is 
	supported.
    </p>
    <h3>
	Static linking
    </h3>
    <p>
	On Windows, Scintilla is normally used as a dynamic library as a .DLL file.
	If you want to link Scintilla directly into your application .EXE or .DLL file, 
	then the STATIC_BUILD preprocessor symbol should be defined and 
	Scintilla_RegisterClasses called. STATIC_BUILD prevents compiling the 
	DllMain function which will conflict with any DllMain defined in your code.
	Scintilla_RegisterClasses takes the HINSTANCE of your application and 
	ensures that the "Scintilla" window class is registered. To make sure that
	the right pointing arrow cursor used in the margin is displayed by Scintilla
	add the scintilla/win32/Margin.cur file to your application's resources with
	the ID IDC_MARGIN which is defined in scintilla/win32/platfromRes.h as 400.
    </p>
    <h3>
	Ensuring lexers are linked into Scintilla
    </h3>
    <p>
	Depending on the compiler and linker used, the lexers may be stripped
	out. This is most often caused when building a static library. To ensure 
	the lexers are linked in, the Scintilla_ForceLexers() function may be 
	called. This function is not normally compiled and to ensure it is compiled
	the preprocessor symbol LINK_LEXERS should be defined.
    </p>
  </body>
</html>

