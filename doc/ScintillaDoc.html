<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />
    <meta name="generator" content="SciTE" />
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>
      Scintilla and SciTE
    </title>
  </head>
  <body bgcolor="#FFFFFF" text="#000000">
    <table bgcolor="#000000" width="100%" cellspacing="0" cellpadding="0" border="0">
      <tr>
        <td>
          <img src="SciTEIco.png" border="3" height="64" width="64" alt="Scintilla icon" />
        </td>
        <td>
          <a href="index.html" style="color:white;text-decoration:none"><font size="5">
          Scintilla</font></a>
        </td>
      </tr>
    </table>

    <style>
    code{font-family: Courier New; font-size: 10pt;}
    </style>

<h1>
   Scintilla Documentation
</h1>
    <p>
       There is <a href="Design.html">an overview of the internal design of Scintilla</a>.<br />
     <a href="ScintillaUsage.html">Some notes on using Scintilla</a>.<br />
       <a href="Steps.html">How to use the Scintilla Edit Control on Windows</a>.<br />
       <a href="http://www.scintilla.org/dmapp.zip">A simple sample using Scintilla from C++ on Windows</a>.<br />
       <a href="http://www.scintilla.org/SciTry.vb">A simple sample using Scintilla from Visual Basic</a>.<br />
       <a href="Lexer.txt">
       A detailed description of how to write a lexer, including a discussion of folding</a>.
    </p>
    <p>
       The <a href="SciCoding.html">coding style</a> used in Scintilla and SciTE
       is worth following if you want to contribute code to Scintilla but is not
       compulsory.
    </p>
    <p>
       For now, the best way to work out how to develop using Scintilla is to see how SciTE uses
      it. SciTE exercises most of Scintilla's facilities.
    </p>
    <p>
      The Windows version of Scintilla is a Windows Control. As such, its primary programming
      interface is through Windows messages. Early versions of Scintilla emulated much of the
      API defined by the standard Windows Edit and Richedit controls but those APIs are now
      deprecated in favour of Scintilla's own, more consistent API.
      In addition to messages performing the actions of a normal Edit control, Scintilla
      allows control of syntax styling, markers, auto-completion and call tips.
    </p>
    <p>
      The GTK+ version also uses messages in a similar way to the Windows version. This is different
      to normal GTK+ practice but made it easier to implement rapidly.
    </p>
    <p>
       In the descriptions that follow, the messages are described as function calls with zero,
       one or two arguments. These two arguments are the standard wParam and lParam familiar
       to Windows programmers. Although the commands only use the arguments described, because
       all messages have two arguments whether Scintilla uses them or not, it is strongly
       recommended that any unused arguments are set to 0. This allows future enhancement of
       messages without the risk of breaking existing code. Common argument types are:
    </p>

<table cellpadding="1" cellspacing="2" border="0">
 <tbody valign=top>
    <tr>
      <th align=left>bool</th>
      <td>
      Arguments expect the values 0 for false and 1 for true.
      </td>
   </tr>
   <tr>
      <th align=left>int</th>
      <td>
      Arguments are 32-bit signed integers.
      </td>
   </tr>
   <tr>
      <th align=left>const char*</th>
      <td>
      Arguments point at text that is being passed to Scintilla but not modified.
      The text may be zero terminated or another argument may specify the character
      count, the description will make this clear.
      </td>
   </tr>
   <tr>
      <th align=left>char*</th>
      <td>
      Arguments point at text buffers that Scintilla will fill with text. In some
      cases another argument will tell Scintilla the buffer size. In others you
      must make sure that the buffer is big enough to hold the requested text.
      </td>
    </tr>
   <tr>
      <th align=left id="colour">colour</th>
      <td>
      Colours are set using the RGB format (Red, Green, Blue). The intensity of each
      colour is set in the range 0 to 255. If you have three such intensities, they
      are combined as: red | (green &lt;&lt; 8) | (blue &lt;&lt; 16). If you set all intensities
      to 255, the colour is white. If you set all intensities to 0, the colour is
      black. When you set a colour, you are making a request. What you will get
      depends on the capabilities of the system and the current screen mode.
      </td>
    </tr>
   <tr>
      <th align=left>&lt;unused&gt;</th>
      <td>
      This is an unused argument. Please set it to 0.
      </td>
    </tr>
  </tbody>
</table>

<h2 id="Message categories">
   Message categories
</h2>
<table border="1">
<tbody>
<tr>
    <td><a href="#Text retrieval and modification">Text retrieval and modification</a></td>
    <td><a href="#Search and replace using the target">Search and replace using the target</a></td>
    <td><a href="#Overtype">Overtype</a></td>
</tr>
<tr>
    <td><a href="#Cut, copy and paste">Cut, copy and paste</a></td>
    <td><a href="#Error handling">Error handling</a></td>
    <td><a href="#Undo and Redo">Undo and Redo</a></td>
</tr>
<tr>
    <td><a href="#Selection and information">Selection and information</a></td>
    <td><a href="#Scrolling and automatic scrolling">Scrolling and automatic scrolling</a></td>
    <td><a href="#Searching">Searching</a></td>
</tr>
<tr>
    <td><a href="#White space">White space</a></td>
    <td><a href="#Cursor">Cursor</a></td>
    <td><a href="#Mouse capture">Mouse capture</a></td>
</tr>
<tr>
    <td><a href="#Line endings">Line endings</a></td>
    <td><a href="#Styling">Styling</a></td>
    <td><a href="#Style definition">Style definition</a></td>
</tr>
<tr>
    <td><a href="#Caret and selection styles">Caret and selection styles</a></td>
    <td><a href="#Margins">Margins</a></td>
    <td><a href="#Other settings">Other settings</a></td>
</tr>
<tr>
    <td><a href="#Brace highlighting">Brace highlighting</a></td>
    <td><a href="#Tabs and Indentation Guides">Tabs and Indentation Guides</a></td>
    <td><a href="#Markers">Markers</a></td>
</tr>
<tr>
    <td><a href="#Indicators">Indicators</a></td>
    <td><a href="#Autocompletion">Autocompletion</a></td>
    <td><a href="#User lists">User lists</a></td>
</tr>
<tr>
    <td><a href="#Calltips">Calltips</a></td>
    <td><a href="#Keyboard commands">Keyboard commands</a></td>
    <td><a href="#Key bindings">Key bindings</a></td>
</tr>
<tr>
    <td><a href="#Popup edit menu">Popup edit menu</a></td>
    <td><a href="#Macro recording">Macro recording</a></td>
    <td><a href="#Direct access">Direct access</a></td>
</tr>
<tr>
    <td><a href="#Multiple views">Multiple views</a></td>
    <td><a href="#Folding">Folding</a></td>
    <td><a href="#Zooming">Zooming</a></td>
</tr>
<tr>
    <td><a href="#Long lines">Long lines</a></td>
    <td><a href="#Lexer">Lexer</a></td>
    <td><a href="#Notifications">Notifications</a></td>
</tr>
<tr>
    <td><a href="#Deprecated messages">Deprecated messages</a></td>
    <td><a href="#Edit messages never supported by Scintilla">Edit messages never supported by Scintilla</a></td>
    <td><a href="#Building Scintilla">Building Scintilla</a></td>
</tr>
</tbody>
</table>
    <p>
    Messages with names of the form SCI_SETxxxxx often have a companion
    SCI_GETxxxxx. To save tedious repetition, if the SCI_GETxxxxx message
    returns the value set by the SCI_SETxxxxx message, the SET routine
    is described and the GET routine is left to your imagination.
    </p>

<h2 id="Text retrieval and modification">
   Text retrieval and modification
</h2>
<pre>
<a href="#SCI_GETTEXT">SCI_GETTEXT(int length, char *text)</a>
<a href="#SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, const char *text)</a>
<a href="#SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</a>
<a href="#SCI_GETLINE">SCI_GETLINE(int line, char *text)</a>
<a href="#SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, const char *text)</a>
<a href="#SCI_SETREADONLY">SCI_SETREADONLY(bool readOnly)</a>
<a href="#SCI_GETREADONLY">SCI_GETREADONLY</a>
<a href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)</a>
<a href="#SCI_ADDTEXT">SCI_ADDTEXT(int length, char *s)</a>
<a href="#SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int length, cell *s)</a>
<a href="#SCI_APPENDTEXT">SCI_APPENDTEXT(int length, char *s)</a>
<a href="#SCI_INSERTTEXT">SCI_INSERTTEXT(int pos, char *text)</a>
<a href="#SCI_CLEARALL">SCI_CLEARALL</a>
<a href="#SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</a>
<a href="#SCI_GETCHARAT">SCI_GETCHARAT(int position)</a>
<a href="#SCI_GETSTYLEAT">SCI_GETSTYLEAT(int position)</a>
<a href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, TEXTRANGE *tr)</a>
<a href="#SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int bits)</a>
<a href="#SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</a>
</pre>
    <p>
    Each character in a Scintilla document is followed by an associated byte of styling
    information. The combination of a character byte and a style byte is called a cell. Style
    bytes are interpreted as a style index in the low 5 bits and as 3 individual bits of
    <a href="#Indicators">indicators</a>. This allows 32 fundamental styles which is enough
    for most languages and three independent indicators so that, for example, syntax errors,
    deprecated names and bad indentation could all be displayed at once. The number of bits used
    for styles can be altered with <a href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>
    up to a maximum of 7 bits. The remaining bits can be used for indicators.
    </p>
    <p>
    Positions within the Scintilla document refer to a character or the gap before that
    character. The first character in a document is 0, the second 1 and so on. If a document
    contains nLen characters the last character is numbered nLen-1. The caret exists between character
    positions and can be located from before the first character (0) to after the last
    character (nLen).
    </p>
    <p>
    There are places where the caret can not go where two character bytes
    make up one character. This occurs when a DBCS character from a language like Japanese
    is included in the document or when line ends are marked with the CP/M
    standard of a carriage return followed by a line feed. The <code>INVALID_POSITION</code> constant (-1)
    represents an invalid position within the document.
    </p>
    <p>
    All lines of text in Scintilla are the same height, and this height is calculated from the
    largest font in any current style. This restriction is for performance as if lines differed
    in height then calculations involving positioning of text would require that text to be
    styled first.
    </p>
    <p>
    <b id="SCI_GETTEXT">SCI_GETTEXT(int length, char *text)</b><br />
    This returns <code>length</code>-1 characters of text from the start of the document plus one
    terminating 0 character. To collect all the text in a document, use <code>SCI_GETLENGTH</code> to get the number
    of characters in the document (<code>nLen</code>), allocate a character buffer of length <code>nLen+1</code> bytes, then call
    <code>SCI_GETTEXT(nLen+1, char *text)</code>. If you then save the text you should use
    <code>SCI_SETSAVEPOINT</code> to    mark the text as unmodified.
    </p><p>
    See also: <a href="#SCI_GETSELTEXT"><code>SCI_GETSELTEXT</code></a>,
     <a href="#SCI_GETCURLINE"><code>SCI_GETCURLINE</code></a>,
     <a href="#SCI_GETLINE"><code>SCI_GETLINE</code></a>,
     <a href="#SCI_GETSTYLEDTEXT"><code>SCI_GETSTYLEDTEXT</code></a>,
     <a href="#SCI_GETTEXTRANGE"><code>SCI_GETTEXTRANGE</code></a>
    </p>
    <p>
    <b id="SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, const char *text)</b><br />
    This replaces all the text in the document with the zero terminated text string you pass in.
    </p>
    <p>
    <b id="SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</b><br />
    This message tells Scintilla that the current state of the document is unmodified.
    This is usually done when the file is saved or loaded, hence the name "save point".
    As Scintilla performs undo and redo operations, it notifies the container that it
    has entered or left the save point with <code>SCN_SAVEPOINTREACHED</code> and
    <code>SCN_SAVEPOINTLEFT</code> <a href="#Notifications">notification messages</a>,
    allowing the container to know if the file should be considered dirty or not.
    </p><p>
    See also: <a href="#SCI_EMPTYUNDOBUFFER"><code>SCI_EMPTYUNDOBUFFER</code></a>,
              <a href="#SCI_GETMODIFY"><code>SCI_GETMODIFY</code></a>
    </p>
    <p>
    <b id="SCI_GETLINE">SCI_GETLINE(int line, char *text)</b><br />
    This fills the buffer defined by text with the contents of the nominated line (lines start
    at 0). The buffer is not terminated by a 0 character. It is up to you to make sure that
    the buffer is long enough for the text, use
    <a href="#SCI_LINELENGTH"><code>SCI_LINELENGTH(int line)</code></a>.
    The returned value is the number of characters copied to the buffer. The returned text
    includes any end of line characters. If you ask for a line number outside the range of lines
    in the document, 0 characters are copied.
    </p><p>
    See also: <a href="#SCI_GETCURLINE"><code>SCI_GETCURLINE</code></a>,
     <a href="#SCI_GETSELTEXT"><code>SCI_GETSELTEXT</code></a>,
     <a href="#SCI_GETTEXTRANGE"><code>SCI_GETTEXTRANGE</code></a>,
     <a href="#SCI_GETSTYLEDTEXT"><code>SCI_GETSTYLEDTEXT</code></a>,
     <a href="#SCI_GETTEXT"><code>SCI_GETTEXT</code></a>
    </p>
    <p>
    <b id="SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, const char *text)</b><br />
    The currently selected text between the anchor and the current position is replaced by the
    0 terminated text string. If the anchor and current position are the same, the text is inserted
    at the caret position. The caret is positioned after the inserted text and the caret is scrolled
    into view.
    </p>
    <p>
    <b id="SCI_SETREADONLY">SCI_SETREADONLY(bool readOnly)</b><br />
    <b id="SCI_GETREADONLY">SCI_GETREADONLY</b><br />
    Set and get the read only flag for the document.
    </p>
    <p>
    <b id="SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)</b><br />
    This collects the text between the positions <code>cpMin</code> and <code>cpMax</code>
    and copies it to <code>lpstrText</code> (see <code>struct TextRange</code> in Scintilla.h).
    If <code>cpMax</code> is -1, text is returned to the end of the
    document. The text is 0 terminated, so you must supply a buffer that is at least 1 character
    longer than the number of characters you wish to read. The return value is the length of the
    returned text not including the terminating 0.
    </p><p>
    See also: <a href="#SCI_GETSELTEXT"><code>SCI_GETSELTEXT</code></a>,
     <a href="#SCI_GETLINE"><code>SCI_GETLINE</code></a>,
     <a href="#SCI_GETCURLINE"><code>SCI_GETCURLINE</code></a>,
     <a href="#SCI_GETSTYLEDTEXT"><code>SCI_GETSTYLEDTEXT</code></a>,
     <a href="#SCI_GETTEXT"><code>SCI_GETTEXT</code></a>
    </p>
    <p>
    <b id="SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, TEXTRANGE *tr)</b><br />
    This collects styled text into a buffer using two bytes for each cell, with
    the character at the lower address of each pair and the style byte at the upper
    address. Characters between the positions cp<code>SCI_GETTEXT</code>Min and
    cpM<code>SCI_GETTEXT</code>ax are copied to lps<code>SCI_GETTEXT</code>trText
    (see <code>struct TextRange</code> in Scintilla.h). Two 0 bytes are added to the end of the text,
    so the buffer that <code>lpstrText</code> points at must be at least
    <code>2*(cpMax-cpMin)+2</code> bytes long.No check is made for sensible values of
    <code>cpMin</code> or <code>cpMax</code>. Positions outside the document
    return character codes and style bytes of 0.
    </p><p>
    See also: <a href="#SCI_GETSELTEXT"><code>SCI_GETSELTEXT</code></a>,
     <a href="#SCI_GETLINE"><code>SCI_GETLINE</code></a>,
     <a href="#SCI_GETCURLINE"><code>SCI_GETCURLINE</code></a>,
     <a href="#SCI_GETTEXTRANGE"><code>SCI_GETTEXTRANGE</code></a>,
     <a href="#SCI_GETTEXT"><code>SCI_GETTEXT</code></a>
    </p>
    <p>
    <b id="SCI_ADDTEXT">SCI_ADDTEXT(int length, char *s)</b><br />
    This inserts the first <code>length</code> characters from the string <code>s</code>
    including any 0's in the string that you might have expected to stop the insert
    operation. The current position is set at the end of the inserted text, but
    it is not scrolled into view.
    </p>
    <p>
    <b id="SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int length, cell *s)</b><br />
    This behaves just like <code>SCI_ADDTEXT</code>, but inserts styled text.
    </p>
    <p>
    <b id="SCI_APPENDTEXT">SCI_APPENDTEXT(int length, char *s)</b><br />
    SCI_APPENDTEXT appends a string to the end of the document
    without changing the selection range.
    </p>
    <p>
    <b id="SCI_INSERTTEXT">SCI_INSERTTEXT(int pos, const char *text)</b><br />
    This inserts the zero terminated <code>text</code> string at position <code>pos</code> or
    at the current position if <code>pos</code> is -1.
    The current position is set at the end of the inserted text, but it is not scrolled into view.
    </p>
    <p>
    <b id="SCI_CLEARALL">SCI_CLEARALL</b><br />
    Unless the document is read only, this deletes all the text.
    </p>
    <p>
    <b id="SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</b><br />
    When wanting to completely restyle the document, for example after choosing a lexer,
    the <code>SCI_CLEARDOCUMENTSTYLE</code> can be used to clear all styling information and
    reset the folding state.
    </p>
    <p>
    <b id="SCI_GETCHARAT">SCI_GETCHARAT(int pos)</b><br />
    This returns the character at <code>pos</code> in the document or 0 if
    <code>pos</code> is negative or past the end of the document.
    </p>
    <p>
    <b id="SCI_GETSTYLEAT">SCI_GETSTYLEAT(int pos)</b><br />
    This returns the style at <code>pos</code> in the document, or 0 if
    <code>pos</code> is negative or past the end of the document.
    </p>
    <p>
    <b id="SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int bits)</b><br />
    <b id="SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</b><br />
    This pair of routines sets and reads back the number of bits in each cell to use for
    styling, to a maximum of 7 style bits. The remaining bits can be used as indicators.
    The standard setting is <code>SCI_SETSTYLEBITS</code>(5).
    </p>

<h2 id="Searching">
   Searching
</h2>
<pre>
<a href="#SCI_FINDTEXT">SCI_FINDTEXT(int flags, TextToFind *ttf)</a>
<a href="#SCI_SEARCHANCHOR">SCI_SEARCHANCHOR</a>
<a href="#SCI_SEARCHNEXT">SCI_SEARCHNEXT(int searchFlags, const char *text)</a>
<a href="#SCI_SEARCHPREV">SCI_SEARCHPREV(int searchFlags, const char *text)</a>
</pre>
    <p>
       <b id="searchFlags"><code>searchFlags</code></b><br />
      Several of the search routines use flag options which include a simple regular
      expression search. Combine the flag options by adding them:
    </p>
   <table border="0">
   <tbody>
    <tr>
        <td><code>SCFIND_MATCHCASE</code></td>
        <td>A match only occurs with text that matches the case of the search string.</td>
    </tr>
    <tr>
        <td><code>SCFIND_WHOLEWORD</code></td>
        <td>A match only occurs if the characters before and after are not word characters.</td>
   </tr>
    <tr>
        <td><code>SCFIND_WORDSTART</code></td>
        <td>A match only occurs if the character before is not a word character.</td>
    </tr>
    <tr>
        <td><code>SCFIND_REGEXP</code></td>
        <td>The search string should be interpreted as a regular expression.</td>
    </tr>
    </tbody>
    </table>
    <p>
      If <code>SCFIND_REGEXP</code> is not included in the <code>searchFlags</code>,
      you can search backwards to find the previous occurance of a search string by
      setting the end of the search range before the start.
      If <code>SCFIND_REGEXP</code> is included searches are always from a lower
      position to a higher position, even if the search range is backwards.
    </p><p>
      In a regular expression, special characters interpreted are:
    </p>
   <table border="0">
   <tbody>
    <tr>
        <td><code>.</code></td>
        <td>Matches any character</td>
    </tr>
    <tr>
        <td><code>\(</code></td>
        <td>This marks the start of a region for tagging a match.</td>
   </tr>
    <tr>
        <td><code>\)</code></td>
        <td>This marks the end of a tagged region.</td>
    </tr>
    <tr>
        <td><code>\n</code></td>
        <td>Where <code>n</code> is 1 through 9 refers to the first through ninth
            tagged region when replacing. For example if the search string was
            <code>Fred\([1-9]\)XXX</code> and the replace string was
            <code>Sam\1YYY</code> applied to <code>Fred2XXX</code>
            this would generate <code>Sam2YYY</code>.</td>
    </tr>
    <tr>
        <td><code>\&lt;</code></td>
        <td>This matches the start of a word using Scintilla's definitions of words.</td>
    </tr>
    <tr>
        <td>\&gt;<code></code></td>
        <td>This matches the end of a word using Scintilla's definition of words.</td>
    </tr>
    <tr>
        <td><code>\x</code></td>
        <td>This allows you to use a character x that would otherwise have a special meaning.
            For example, \[ would be interpreted as [ and not as the start of a character set.</td>
    </tr>
    <tr>
        <td><code>[...]</code></td>
        <td>This indicates a set of characters, for example [abc] means any of the characters
            a, b or c. You can also use ranges, for example [a-z] for any lower case character.</td>
    </tr>
    <tr>
        <td><code>[^...]</code></td>
        <td>The complement of the characters in the set. For example, [^A-Za-z] means any character
        except an alphabetic character.</td>
    </tr>
    <tr>
        <td><code>^</code></td>
        <td>This matches the start of a line (unless used inside a set, see above).</td>
    </tr>
    <tr>
        <td><code>$</code></td>
        <td>This matches the end of a line.</td>
    </tr>
    <tr>
        <td><code>*</code></td>
        <td>This matches 0 or more times. For example <code>Sa*m</code>
            matches <code>Sm</code>, <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
    </tr>
    <tr>
        <td><code>+</code></td>
        <td>This matches 1 or more times. For example <code>Sa+m</code>
            matches <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
    </tr>
    </tbody>
    </table>

    <p>
     <b id="SCI_FINDTEXT">SCI_FINDTEXT(int searchFlags, TextToFind *ttf)</b><br />
       This message searches for text in the document. It does not use or move the
       current selection. The <a href="#searchFlags"><code>searchFlags</code></a> argument
       controls the search type, which includes regular expression searches.
    </p><p>
       The <code>TextToFind</code> structure is defined in Scintilla.h; set
       <code>chrg.cpMin</code> and <code>chrg.cpMax</code> with the range of
       positions in the document to search. If <code>SCFIND_REGEXP</code> is
       included in the flags, the search is always
       forwards (even if <code>chrg.cpMax</code> is less than <code>chrg.cpMin</code>).
       If <code>SCFIND_REGEXP</code> is
       not included, you can search backwards by setting <code>chrg.cpMax</code> less than
       <code>chrg.cpMin</code>. Set the <code>lpstrText</code> member of
       <code>TextToFind</code> to point at a zero terminated
       text string holding the search pattern. If your language makes the use of
       <code>TextToFind</code> difficult, you should consider using
       <code>SCI_SEARCHINTARGET</code> instead.
    </p><p>
       The return value is -1 if the search fails or the position of the start of
       the found text it is succeeds. The <code>chrgText.cpMin</code> and
       <code>chrgText.cpMax</code> members
       of <code>TextToFind</code> are filled in with the start and end positions of the found text.
    </p><p>
       See also: <a href="#SCI_SEARCHINTARGET"><code>SCI_SEARCHINTARGET</code></a>
    </p>
    <p>
    <b id="SCI_SEARCHANCHOR">SCI_SEARCHANCHOR</b><br />
    <b id="SCI_SEARCHNEXT">SCI_SEARCHNEXT(int searchFlags, const char *text)</b><br />
    <b id="SCI_SEARCHPREV">SCI_SEARCHPREV(int searchFlags, const char *text)</b><br />
    These messages provide relocatable search support. This allows  multiple incremental
    interactive searches to be macro recorded while still setting the selection to found
    text so the find/select operation is self-contained. These three messages send
    <code>SCN_MACRORECORD</code> <a href="#Notifications">notifications</a> if
    macro recording is enabled.
    </p><p>
    <code>SCI_SEARCHANCHOR</code> sets the search start point used by <code>SCI_SEARCHNEXT</code> and
    <code>SCI_SEARCHPREV</code> to the start of the current selection, that is, the
    end of the selection that is nearer to the start of the document. You should
    always call this before calling either of <code>SCI_SEARCHNEXT</code> or <code>SCI_SEARCHPREV</code>.
    </p><p>
    <code>SCI_SEARCHNEXT</code> and <code>SCI_SEARCHPREV</code> search for the next
    and previous occurance of
    the zero terminated search string pointed at by text. The search is modified by
    the <a href="#searchFlags"><code>searchFlags</code></a>. If you request a regular expression,
    <code>SCI_SEARCHPREV</code> finds the first occurance of the seach string in the document,
    not the previous one before the anchor point.
    </p><p>
    The return value is -1 if nothing is found, otherwise the return value is the
    start position of the matching text. The selection is updated to show the
    matched text, but is not scrolled into view.
    </p><p>
    See also: <a href="#SCI_SEARCHINTARGET"><code>SCI_SEARCHINTARGET</code></a>,
              <a href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a>
    </p>

<h3 id="Search and replace using the target">
    Search and replace using the target
</h3>
<pre>
<a href="#SCI_SETTARGETSTART">SCI_SETTARGETSTART(int pos)</a>
<a href="#SCI_GETTARGETSTART">SCI_GETTARGETSTART</a>
<a href="#SCI_SETTARGETEND">SCI_SETTARGETEND(int pos)</a>
<a href="#SCI_GETTARGETEND">SCI_GETTARGETEND</a>
<a href="#SCI_REPLACETARGET">SCI_REPLACETARGET(int length, const char *text)</a>
<a href="#SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int length, const char *text)</a>
<a href="#SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int searchFlags)</a>
<a href="#SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</a>
<a href="#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int length, const char *text)</a>
</pre>
    <p>
    Using <a href="#SCI_REPLACESEL"><code>SCI_REPLACESEL</code></a>, modifications
    cause scrolling and other visible changes which may take some time and cause
    unwanted display updates. If performing many changes, such as a replace all
    command, the target can be used instead. First set the range to be replaced.
    Then call <code>SCI_REPLACETARGET</code> or <code>SCI_REPLACETARGETRE</code>.
    </p>
    <p>
    Searching can be performed within the target range with <code>SCI_SEARCHINTARGET</code>
    which uses a counted string to allow searching for null characters.
    Returns length of range or -1 for failure in which case target is not moved.
    The flags used by <code>SCI_SEARCHINTARGET</code> such as <code>SCFIND_MATCHCASE</code>,
    <code>SCFIND_WHOLEWORD</code>, <code>SCFIND_WORDSTART</code>, and <code>SCFIND_REGEXP</code> can
    be set with <code>SCI_SETSEARCHFLAGS</code>. <code>SCI_SEARCHINTARGET</code> may
    be simpler for some clients to use than <a href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a>
    as that requires using a pointer to a structure.
    </p>
    <p>
    <b id="SCI_SETTARGETSTART">SCI_SETTARGETSTART(int pos)</b><br />
    <b id="SCI_GETTARGETSTART">SCI_GETTARGETSTART</b><br />
    <b id="SCI_SETTARGETEND">SCI_SETTARGETEND(int pos)</b><br />
    <b id="SCI_GETTARGETEND">SCI_GETTARGETEND</b><br />
    These functions set and return the start and end of the target. When searching in
    non-regular expression mode, you can set start greater than end to find the last
    matching text in the target rather than the first matching text. The target is also
    set by a sucessful <code>SCI_SEARCHINTARGET</code>.
    </p>
    <p>
    <b id="SCI_REPLACETARGET">SCI_REPLACETARGET(int length, const char *text)</b><br />
    If length is -1, text is a zero terminated string, otherwise length sets the number
    of character to replace the target with. The return value is the length of the replacement
    string.
    </p>
    <p>
    <b id="SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int length, const char *text)</b><br />
    This replaces the target using regular expressions. The replacement string is formed
    from the text string with any sequences of <code>\1</code> through <code>\9</code>
    replaced by tagged matches from the most recent regular expression search. The
    return value is the length of the replacement string.
    </p>
    <p>
    <b id="SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int searchFlags)</b><br />
    <b id="SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</b><br />
    These get and set the <a href="#searchFlags"><code>searchFlags</code></a> used by
    <code>SCI_SEARCHINTARGET</code>.
    There are several option flags including a simple regular expression search.<br />
    </p>
    <p>
    <b id="SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int length, const char *text)</b><br />
    This searches for the first occurance of a text string in the target defined by
    <code>SCI_SETTARGETSTART</code> and <code>SCI_SETTARGETEND</code>. The text string
    is not zero terminated; the size is set by <code>length</code>. The search is modified
    by the search flags set by <code>SCI_SETSEARCHFLAGS</code>. If the search succeeds,
    the target is set to the found text and the return value is the position of the
    start of the matching text. If the search fails, the result is -1.
    </p><p>
    See also: <a href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a>
    </p>

<h2 id="Overtype">
    Overtype
</h2>
<pre>
SCI_SETOVERTYPE(bool overType)
SCI_GETOVERTYPE
</pre>
    <p>
      <code>SCI_GETOVERTYPE</code> returns <code>TRUE</code> (1) if overtyping is active otherwise
      <code>FALSE</code> (0) will be returned. Use <code>SCI_GETOVERTYPE</code> to set the overtype node.
    </p>

<h2 id="Cut, copy and paste">
   Cut, copy and paste
</h2>
<pre>
SCI_CUT
SCI_COPY
SCI_PASTE
SCI_CLEAR
SCI_CANPASTE
</pre>
    <p>
    These commands perform the standard tasks of cutting and copying data to the clipboard,
    pasting from the clipboard into the document, and clearing the document.
    <code>SCI_CANPASTE</code> returns non-zero if there is anything in the clipboard in
    a suitable format for pasting. If you need a "can copy" or "can cut", use
    <code>SCI_GETSELECTIONSTART()-SCI_GETSELECTIONEND()</code>
    which will be non-zero if you can copy or cut to the clipboard.
    </p>

<h2 id="Error handling">
   Error handling
</h2>
    <p>
    <b id="">SCI_SETSTATUS(int status)</b><br />
    <b id="">SCI_GETSTATUS</b><br />
    If an error occurs, Scintilla may set an internal error number that can be retrieved with
    <code>SCI_GETSTATUS</code>. Not currently used but will be in the future. To clear the error status
    call <code>SCI_SETSTATUS(0)</code>.
    </p>

<h2 id="Undo and Redo">
   Undo and Redo
</h2>
<pre>
<a href="#SCI_UNDO">SCI_UNDO</a>
<a href="#SCI_CANUNDO">SCI_CANUNDO</a>
<a href="#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</a>
<a href="#SCI_REDO">SCI_REDO</a>
<a href="#SCI_CANREDO">SCI_CANREDO</a>
<a href="#SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool collectUndo)</a>
<a href="#SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</a>
<a href="#SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION</a>
<a href="#SCI_ENDUNDOACTION">SCI_ENDUNDOACTION<a>
</pre>
    <p>
    Scintilla has multiple level undo and redo. It will continue to collect undoable actions
    until memory runs out. Scintilla saves actions that change the document. Scintilla does not
    save caret and selection movements, view scrolling and the like. Sequences of typing or
    deleting are compressed into single actions to make it easier to undo and redo at a
    sensible level of detail. Sequences of actions can be combined into actions that are
    undone as a unit. These sequences occur between <code>SCI_BEGINUNDOACTION</code> and
    <code>SCI_ENDUNDOACTION</code> messages. These sequences can be nested and only
    the top level sequences are undone as units.
    </p>
    <p>
    <b id="SCI_UNDO">SCI_UNDO</b><br />
    <b id="SCI_CANUNDO">SCI_CANUNDO</b><br />
    <code>SCI_UNDO</code> undoes one action, or if the undo buffer has reached a
    <code>SCI_ENDUNDOACTION</code> point, all the actions back to the corresponding
    <code>SCI_BEGINUNDOACTION</code>.
    </p><p>
    <code>SCI_CANUNDO</code> returns 0 if there is nothing to undo, and 1 if there is.
    You would typically use the result of this message to enable/disable the Edit menu
    Undo command.
    </p>
    <p>
    <b id="SCI_REDO">SCI_REDO</b><br />
    <b id="SCI_CANREDO">SCI_CANREDO</b><br />
    <code>SCI_REDO</code> undoes the effect of the last <code>SCI_UNDO</code> operation.
    </p><p>
    <code>SCI_CANREDO</code> returns 0 if there is no action to redo and 1 if there are undo actions
    to redo. You could typically use the result of this message to enable/disable the
    Edit menu Redo command.
    </p>
    <p>
    <b id="SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</b><br />
    This command tells Scintilla to forget any saved undo or redo history. It also sets the save
    point to the start of the undo buffer, so the document will appear to be unmodified. This
    does not cause the <code>SCN_SAVEPOINTREACHED</code> notification to be sent to the container.
    </p><p>
    See also: <a href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>
    </p>
    <b id="SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool collectUndo)</b><br />
    <b id="SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</b><br />
    You can control whether Scintilla collects undo information with
    <code>SCI_SETUNDOCOLLECTION</code>. Pass in <code>true</code> (1) to collect
    information and <code>false</code> (0) to stop collecting. If you stop
    collection, you should also use <code>SCI_EMPTYUNDOBUFFER</code> to avoid the
    undo buffer being unsynchronised with the data in the buffer.
    </p><p>
    You might wish to turn off saving undo information if you use the Scintilla to store
    text generated by a program (a Log view) or in a display window where text is often
    deleted and regenerated.
    </p>
    <p>
    <b id="SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION</b><br />
    <b id="SCI_ENDUNDOACTION">SCI_ENDUNDOACTION</b><br />
    Send these two messages to Scintilla to mark the beginning and end of a set of operations
    that you want to undo all as one operation but that you have to generate as several
    operations. Alternatively, you can use these to mark a set of operations that you do
    not want to have combined with the preceding or following operations if they are undone.
    </p>

<h2 id="Selection and information">
Selection and information
</h2>
<pre>
<a href="#SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH</a>
<a href="#SCI_GETLENGTH">SCI_GETLENGTH</a>
<a href="#SCI_GETLINECOUNT">SCI_GETLINECOUNT</a>
<a href="#SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</a>
<a href="#SCI_LINESONSCREEN">SCI_LINESONSCREEN</a>
<a href="#SCI_GETMODIFY">SCI_GETMODIFY</a>
<a href="#SCI_SETSEL">SCI_SETSEL(int anchorPos, int currentPos)</a>
<a href="#SCI_GOTOPOS">SCI_GOTOPOS(int position)</a>
<a href="#SCI_GOTOLINE">SCI_GOTOLINE(int line)</a>
<a href="#SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int position)</a>
<a href="#SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</a>
<a href="#SCI_SETANCHOR">SCI_SETANCHOR(int position)</a>
<a href="#SCI_GETANCHOR">SCI_GETANCHOR</a>
<a href="#SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int position)</a>
<a href="#SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART</a>
<a href="#SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int position)</a>
<a href="#SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</a>
<a href="#SCI_SELECTALL">SCI_SELECTALL</a>
<a href="#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int position)</a>
<a href="#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int line)</a>
<a href="#SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</a>
<a href="#SCI_LINELENGTH">SCI_LINELENGTH(int line)</a>
<a href="#SCI_GETCOLUMN">SCI_GETCOLUMN(int position)</a>
<a href="#SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int x, int y)</a>
<a href="#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int x, int y)</a>
<a href="#SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int position)</a>
<a href="#SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int position)</a>
<a href="#SCI_HIDESELECTION">SCI_HIDESELECTION(bool hide)</a>
<a href="#SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, char *text)</a>
<a href="#SCI_GETCURLINE">SCI_GETCURLINE(int textlen, char *text)</a>
<a href="#SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</a>
<a href="#SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</a>
<a href="#SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int position, bool onlyWordCharacters)</a>
<a href="#SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int position, bool onlyWordCharacters)</a>
<a href="#SCI_TEXTWIDTH">SCI_TEXTWIDTH(int stylenumber, char *text)</a>
<a href="#SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int line)</a>
</pre>
    <p>
    Scintilla maintains a selection which stretches between two points, the anchor and the
    current position. If the anchor and the current position are the same, there is no selected
    text. Positions in the document range from 0 (before the first character), to the document
    size (after the last character). If you use messages, there is nothing to stop you setting
    a position that is in the middle of a CRLF pair, or in the middle of a 2 byte character.
    However, keyboard commands will not move the caret into such positions.
    </p>

    <p>
    <b id="SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH</b><br />
    <b id="SCI_GETLENGTH">SCI_GETLENGTH</b><br />
    Both these messages return the length of the document in characters.
    </p>
    <p>
    <b id="SCI_GETLINECOUNT">SCI_GETLINECOUNT</b><br />
    This returns the number of lines in the document. An empty document contains 1 line. A document
    holding only an end of line sequence has 2 lines.
    </p>
    <p>
    <b id="SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</b><br />
    This returns the line number of the first visible line in the Scintilla view. The first line
    in the document is numbered 0.
    </p>
    <p>
    <b id="SCI_LINESONSCREEN">SCI_LINESONSCREEN</b><br />
    This returns the number of complete lines visible on the screen. With a constant line
    height, this is the vertical space available divided by the line separation. Unless you
    arrange to size your window to an integral number of lines, there may be a partial line
    visible at the bottom of the view.
    </p>
    <p>
    <b id="SCI_GETMODIFY">SCI_GETMODIFY</b><br />
    This returns non-zero if the document is "modified" and 0 if it is "unmodified".
    The modified status of a document is determined by the undo position relative to the
    save point. The save point is set by <a href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>,
    usually when you have saved data to a file.
    </p><p>
    If you need to be notified when the document becomes modified, Scintilla notifies
    the container that it has entered or left the save point with the
    <code>SCN_SAVEPOINTREACHED</code> and <code>SCN_SAVEPOINTLEFT</code>
    <a href="#Notifications">notification messages</a>.
    </p>
    <p>
    <b id="SCI_SETSEL">SCI_SETSEL(int anchorPos, int currentPos)</b><br />
    If <code>currentPos</code> is negative, it means the end of the document. If
    <code>anchorPos</code> is negative it means remove any selection (i.e. set
    the anchor to the same position as <code>currentPos</code>). The caret is
    scrolled into view after this operation.
    </p>
    <p>
    <b id="SCI_GOTOPOS">SCI_GOTOPOS(int pos)</b><br />
    This removes any selection, sets the caret at <code>pos</code> and scrolls the view to make
    the caret visible, if necessary. It is equivalent to <code>SCI_SETSEL(pos,pos)</code>.
    The anchor position is set the same as the current position.
    </p>
    <p>
    <b id="SCI_GOTOLINE">SCI_GOTOLINE(int line)</b><br />
    If <code>line</code> is outside the lines in the document (first line is 0), the line set is the
    first or last. This removes any selection and sets the caret at the
    start of the line and scrolls the view (if needed) to make it visible. The anchor
    position is set the same as the current position.
    </p>
    <p>
    <b id="SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int pos)</b><br />
    This sets the current position and creates a selection between the anchor and the
    current position. The caret is not scrolled into view.
    </p><p>
    See also: <a href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a>
    </p>
    <p>
    <b id="SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</b><br />
    This returns the current position.
    </p>
    <p>
    <b id="SCI_SETANCHOR">SCI_SETANCHOR(int pos)</b><br />
    This sets the anchor position and creates a selection between the anchor position and the
    current position. The caret is not scrolled into view.
    </p><p>
    See also: <a href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a>
    </p>
    <p>
    <b id="SCI_GETANCHOR">SCI_GETANCHOR</b><br />
    This returns the current anchor position.
    </p>
    <p>
    <b id="SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int pos)</b><br />
    <b id="SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int pos)</b><br />
    These set the selection based on the assumption that the anchor position is less than
    the current position. They do not make the caret visible.
    </p>
    <TABLE BORDER>
    <thead align=center>
    <tr><th></th>                      <th>anchor</th>                 <th>current</th></tr>
    </thead>
    <tbody align=center>
    <tr>
        <th><code>SCI_SETSELECTIONSTART</code></th>
        <td><code>pos</code></td>
        <td><code>Max(pos, current)</code></td></tr>
    <tr>
        <th><code>SCI_SETSELECTIONEND</code></th>
        <td><code>Min(anchor, pos)</code></td>
        <td><code>pos</code></td></tr>
    </tbody>
    </table>
    <p>
    See also: <a href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a>
    </p>
    <p>
    <b id="SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART</b><br />
    <b id="SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</b><br />
    These return the start and end of the selection without regard to which end
    is the current position and which is the anchor.<code>SCI_GETSELECTIONSTART</code> returns
    the smaller of the current position or the anchor position. <code>SCI_GETSELECTIONEND</code>
    returns the larger of the two values.
    </p>
    <p>
    <b id="SCI_SELECTALL">SCI_SELECTALL</b><br />
    This selects all the text in the document. The current postion is not scrolled into view.
    </p>
    <p>
    <b id="SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int pos)</b><br />
    This message returns the line that contains the position <code>pos</code> in the document.
    The return value is 0 if <code>pos</code> <= 0. The return value is the last line if
    <code>pos</code> is beyond the end of the document.
    </p>
    <p>
    <b id="SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int line)</b><br />
    This returns the document position that corresponds with the start of the line. If
    <code>line</code> is negative, the position of the line holding the start of the selection is
    returned. If <code>line</code> is greater than the lines in the document, the return value is -1.
    If <code>line</code> is equal to the number of lines in the document (i.e. 1 line past the last line),
    the return value is the end of the document.
    </p>
    <p>
    <b id="SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</b><br />
    This returns the position at the end of the line, before any line end characters. If
    <code>line</code> is negative, the result is 0. If <code>line</code> is the last line in
    the document, (which does
    not have any end of line characters), the result is the size of the document.
    If <code>line</code> is negative, the result is -1.
    If <code>line</code> is >= <code>SCI_GETLINECOUNT()</code>, the result is currently
    <code>SCI_GETLENGTH()-1</code>... (undefined?).
    </p>
    <p>
    <b id="SCI_LINELENGTH">SCI_LINELENGTH(int line)</b><br />
    This returns the length of the line, including any line end characters. If <code>line</code>
    is negative or beyond the last line in the document, the result is 0. If you want the
    length of the line not including any end of line characters use
    <code><a href="#SCI_GETLINENDPOSITION">SCI_GETLINENDPOSITION(line)</a> -
    <a href="#SCI_GETLINEPOSITION">SCI_GETLINEPOSITION(line)</a></code>.
    </p>
    <b id="SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, char *text)</b><br />
    This copies the currently selected text and a terminating 0 byte to the <code>text</code> buffer.
    The buffer must be at least <code>SCI_GETSELECTIONEND()-SCI_SETSELECTIONSTART()+1</code> bytes
    long.
    </p><p>
    See also: <a href="#SCI_GETCURLINE"><code>SCI_GETCURLINE</code></a>,
     <a href="#SCI_GETLINE"><code>SCI_GETLINE</code></a>,
     <a href="#SCI_GETTEXT"><code>SCI_GETTEXT</code></a>,
     <a href="#SCI_GETSTYLEDTEXT"><code>SCI_GETSTYLEDTEXT</code></a>,
     <a href="#SCI_GETTEXTRANGE"><code>SCI_GETTEXTRANGE</code></a>
    </p>
    <p>
    <b id="SCI_GETCURLINE">SCI_GETCURLINE(int textlen, char *text)</b><br />
    This retrieves the text of the line containing the caret and returns the position
    within the line of the caret. Pass in <code>char* text</code> pointing at a buffer large enough
    to hold the text you wish to retrieve and a terminating 0 character. Set <code>textLen</code> to
    the length of the buffer.
    </p><p>
    See also: <a href="#SCI_GETSELTEXT"><code>SCI_GETSELTEXT</code></a>,
     <a href="#SCI_GETLINE"><code>SCI_GETLINE</code></a>,
     <a href="#SCI_GETTEXT"><code>SCI_GETTEXT</code></a>,
     <a href="#SCI_GETSTYLEDTEXT"><code>SCI_GETSTYLEDTEXT</code></a>,
     <a href="#SCI_GETTEXTRANGE"><code>SCI_GETTEXTRANGE</code></a>
    </p>
    <p>
    <b id="SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</b><br />
    This returns 1 if the current selection is in rectangle mode, 0 if not.
    </p>
    <p>
    <b id="SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</b><br />
    If the caret is off the top or bottom of the view, it is moved to the nearest line
    that is visible to its current position. Any selection is lost.
    </p>
    <p>
    <b id="SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int position, bool onlyWordCharacters)</b><br />
    <b id="SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int position, bool onlyWordCharacters)</b><br />
    These messages return the start and end of words using the same definition of
    words as used internally within Scintilla. You can set your own list of characters that count
    as words with <a href="#SCI_SETWORDCHARS"><code>SCI_SETWORDCHARS</code></a>. The position sets the start
    or the search, which is forwards when searching for the end and backwards when searching for
    the start.
    </p><p>
    Set <code>onlyWordCharacters</code> to <code>true</code> (1) to stop searching at the
    first non-word character in the
    search direction. If <code>onlyWordCharacters</code> is <code>false</code> (0), the first
    character in the search direction
    sets the type of the search as word or non-word and the search stops at the first non-matching
    character. Searches are also terminated by the start or end of the document.
    </p><p>
    If "w" represents word characters and "." represents non-word characters and
    "|" represents the position and <code>true</code> or <code>false</code> is the state
     of <code>onlyWordCharacters</code>:
    </p>
    <TABLE cellpadding="3" cellspacing="0" border="1">
    <thead align=center>
    <tr><th>Initial state</th> <th>end, true</th> <th>end, false</th> <th>start, true</th> <th>start, false</th></tr>
    </thead>
    <tbody align=center>
    <tr><td>..ww..|..ww..</td> <td>..ww..|..ww..</td> <td>..ww....|ww..</td> <td>..ww..|..ww..</td> <td>..ww|....ww..</td></tr>
    <tr><td>....ww|ww....</td> <td>....wwww|....</td> <td>....wwww|....</td> <td>....|wwww....</td> <td>....|wwww....</td></tr>
    <tr><td>..ww|....ww..</td> <td>..ww|....ww..</td> <td>..ww....|ww..</td> <td>..|ww....ww..</td> <td>..|ww....ww..</td></tr>
    <tr><td>..ww....|ww..</td> <td>..ww....ww|..</td> <td>..ww....ww|..</td> <td>..ww....|ww..</td> <td>..ww|....ww..</td></tr>
    </tbody>
    </table>
    <p>
    <b id="SCI_TEXTWIDTH">SCI_TEXTWIDTH(int stylenumber, char *text)</b><br />
    This returns the pixel width of a string drawn in the given <code>stylenumber</code>
    which can be used, for example,
    to decide how wide to make the line number margin in order to display a given
    number of numerals.
    </p>
    <p>
    <b id="SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int line)</b><br />
    This returns the height in pixels of a particular line. Currently all
    lines are the same height.
    </p>
    <p>
    <b id="SCI_GETCOLUMN">SCI_GETCOLUMN(int pos)</b><br />
    This message returns the column number of a position <code>pos</code> within the
    document taking the width of tabs into account. This returns the
    column number of the last tab on the line before <code>pos</code>, plus
    the number of
    characters between the last tab and <code>pos</code>.If there are no tabs
    characters on the line, the return value is the number of
    characters up to the position on the line.  In both cases, double byte
    characters count as a single character. This is
    probably only useful with monospaced fonts.
    </p>
    <p>
    <b id="SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int x, int y)</b><br />
    <b id="SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int x, int y)</b><br />
    <code>SCI_POSITIONFROMPOINT</code> finds the closest character position to a point and
    <code>SCI_POSITIONFROMPOINTCLOSE</code> is similar but returns -1 if the point is
    outside the window or not close to any characters.
    </p>
    <p>
    <b id="SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int pos)</b><br />
    <b id="SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int pos)</b><br />
    These messages return the x and y display pixel location of text at position <code>pos</code> in the document.
    </p>
    <p>
    <b id="SCI_HIDESELECTION">SCI_HIDESELECTION(bool hide)</b><br />
    The normal state is to make the selection visible by drawing it as set by
    <a href="#SCI_SETSELFORE"><code>SCI_SETSELFORE</code></a> and
    <a href="#SCI_SETSELBACK"><code>SCI_SETSELBACK</code></a>. However, if you hide the selection, it is
    drawn as normal text.
    </p>

    <h2 id="Scrolling and automatic scrolling">
       Scrolling and automatic scrolling
    </h2>
<pre>
<a href="#SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</a>
<a href="#SCI_SCROLLCARET">SCI_SCROLLCARET</a>
<a href="#SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int caretPolicy, int caretSlop)</a>
<a href="#SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop)</a>
<a href="#SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int caretPolicy, int caretSlop)</a>
<a href="#SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)</a>
<a href="#SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</a>
<a href="#SCI_GETXOFFSET">SCI_GETXOFFSET</a>
<a href="#SCI_SETXOFFSET">SCI_SETXOFFSET(int xoffset)</a>
<a href="#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int pixelWidth)</a>
<a href="#SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</a>
<a href="#SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool endAtLastLine)</a>
<a href="#SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</a>
</pre>
    <p>
    <b id="SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</b><br />
      This will attempt to scroll the display by the number of columns and lines that
      you specify. Positive line values increase the line number at the top of the
      screen (i.e. they move the text upwards as far as the user is concerned), Negative
      line values do the reverse.
    </p><p>
      The column measure is the width of a space in the default style. Positive values
      increase the column at the left edge of the view (i.e. they move the text leftwards
      as far as the user is concerned). Negative values do the reverse.
    </p><p>
    See also:<a href="#SCI_SETXOFFSET"><code>SCI_SETXOFFSET</code></a>
    </p>
    <p>
    <b id="SCI_SCROLLCARET">SCI_SCROLLCARET</b><br />
      If the current position (this is the caret if there is no selection) is not visible
      the view is scrolled to make it visable according to the current caret policy.
    </p>
    <p>
    <b id="SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int caretPolicy, int caretSlop)</b><br />
    <b id="SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop)</b><br />
      These set the caret policy. The value of <code>caretPolicy</code> is a combination of
      <code>CARET_SLOP</code>, <code>CARET_STRICT</code>, <code>CARET_JUMPS</code> and <code>CARET_EVEN</code>.
     </p>
   <table cellpadding="1" cellspacing="2" border="0">
   <tbody valign=top >
    <tr>
      <th align=left><code>CARET_SLOP</code></th>
      <td>If set, we can define a slop value: <code>caretSlop</code>.
      This value defines an unwanted zone (UZ) where the caret is... unwanted.
      This zone is defined as a number of pixels near the vertical margins,
      and as a number of lines near the horizontal margins.
      By keeping the caret away from the edges, it is seen within its context,
      so it is likely that the identifier that the caret is on can be completely seen,
      and that the current line is seen with some of the lines following it which are
      often dependent on that line.
      </td>
   </tr>
   <tr>
      <th align=left><code>CARET_STRICT</code></th>
      <td>If set, the policy set by <code>CARET_SLOP</code> is enforced... strictly.
      The caret is centred on the display if <code>caretSlop</code> is not set,
      and cannot go in the UZ if <code>caretSlop</code> is set.
      </td>
   </tr>
   <tr>
      <th align=left><code>CARET_JUMPS</code></th>
      <td>If set, the display is moved more energetically
      so the caret can move in the same direction longer before the policy is applied again.
      '3UZ' notation is used to indicate three time the size of the UZ as a distance to the margin.
      </td>
   </tr>
   <tr>
      <th align=left><code>CARET_EVEN</code></th>
      <td>If not set, instead of having symmetrical UZs,
      the left and bottom UZs are extended up to right and top UZs respectively.
      This way, we favour the displaying of useful information: the begining of lines,
      where most code reside, and the lines after the caret, eg. the body of a function.
      </td>
    </tr>
    </tbody>
  </table>
    <p></p>
    <table cellpadding="3" cellspacing="0" border="1">
    <thead align=center>
     <tr>
      <th>slop</th>
      <th>strict</th>
      <th>jumps</th>
      <th>even</th>
      <th>Caret can go to the margin</th>
      <th>On reaching limit (going out of visibility<br />
          orgoing into the UZ) display is...</th>
     </tr>
     </thead>
     <tbody align=center>
     <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>Yes</td>
      <td>moved to put caret on top/on right</td>
     </tr>
     <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>Yes</td>
      <td>moved by one position</td>
     </tr>
     <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>Yes</td>
      <td>moved to put caret on top/on right</td>
     </tr>
     <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>Yes</td>
      <td>centred on the caret</td>
     </tr>
     <tr>
      <td>0</td>
      <td>1</td>
      <td>-</td>
      <td>0</td>
      <td>Caret is always on top/on right of display</td>
      <td>-</td>
     </tr>
     <tr>
      <td>0</td>
      <td>1</td>
      <td>-</td>
      <td>1</td>
      <td>No, caret is always centred</td>
      <td>-</td>
     </tr>
     <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>Yes</td>
      <td>moved to put caret out of the asymmetrical UZ</td>
     </tr>
     <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>Yes</td>
      <td>moved to put caret out of the UZ</td>
     </tr>
     <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>Yes</td>
      <td>moved to put caret at 3UZ of the top or right margin</td>
     </tr>
     <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>Yes</td>
      <td>moved to put caret at 3UZ of the margin</td>
     </tr>
     <tr>
      <td>1</td>
      <td>1</td>
      <td>-</td>
      <td>0</td>
      <td>Caret is always at UZ of top/right margin</td>
      <td>-</td>
     </tr>
     <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>No, kept out of UZ</td>
      <td>moved by one position</td>
     </tr>
     <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>No, kept out of UZ</td>
      <td>moved to put caret at 3UZ of the margin</td>
     </tr>
     </tbody>
    </table>
    <p>
    <b id="SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int caretPolicy, int caretSlop)</b><br />
      This determines how the vertical positioning is determined when
      <a href="#SCI_ENSUREVISIBLEENFORCEPOLICY"><code>SCI_ENSUREVISIBLEENFORCEPOLICY</code></a> is called.
      It takes <code>VISIBLE_SLOP</code> and <code>VISIBLE_STRICT</code> flags for the policy parameter. It is similar
      in operation to <a href="#SCI_SETYCARETPOLICY"><code>SCI_SETYCARETPOLICY</code>(int caretPolicy, int caretSlop)</a>.
    </p>
    <p>
    <b id="SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)</b><br />
    <b id="SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</b><br />
      The horizontal scroll bar is only displayed if it is needed. If you never wish to
      see it, call <code>SCI_SETHSCROLLBAR(0)</code>. Use <code>SCI_SETHSCROLLBAR(1)</code> to
      enable it again. <code>SCI_GETHSCROLLBAR</code> returns the current state. The default state
      is to display it when needed.
    </p>
    <p>
    <b id="SCI_SETXOFFSET">SCI_SETXOFFSET(int xoffset)</b><br />
    <b id="SCI_GETXOFFSET">SCI_GETXOFFSET</b><br />
      The xoffset is the horizontal scroll position in pixels of the start of the text view.
      A value of 0 is the normal position with the first text column visible at the left of
      the view.
    <p></p>
    See also: <a href="#SCI_LINESCROLL"><code>SCI_LINESCROLL</code></a>
    </p>
    <p>
    <b id="SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int pixelWidth)</b><br />
    <b id="SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</b><br />
      These set and get the document width in pixels assumed by Scintilla when calculating
      how to display the horizontal scroll bar. The default value is 2000.
    </p>
    <p>
    <b id="SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool endAtLastLine)</b><br />
    <b id="SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</b><br />
      <code>SCI_SETENDATLASTLINE</code> sets the scroll range so that maximum
      scroll position has the last line at the bottom of the view (default).
      Setting this to false allows scrolling one page below the last line.
    </p>


<h2 id="White space">
   White space
</h2>
<pre>
<a href="#SCI_SETVIEWWS">SCI_SETVIEWWS(int wsMode)</a>
<a href="#SCI_GETVIEWWS">SCI_GETVIEWWS</a>
<a href="#SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE(bool useWhitespaceForeColour, int colour)</a>
<a href="#SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool useWhitespaceBackColour, int colour)</a>
</pre>
    <p>
    <b id="">SCI_SETVIEWWS(int wsMode)</b><br />
    <b id="">SCI_GETVIEWWS</b><br />
    White space can be made visible which may useful for languages in which
    whitespace is significant, such as Python. Space characters appear as small
    centred dots and tab characters as light arrows pointing to the right. There
    are also ways to control the display of <a href="#Line endings">end of
    line characters</a>. The two messages set and get the white space display
    mode. The wsMode argument can be one of:
    </p>
  <table cellpadding="1" cellspacing="2" border="0">
   <tbody valign=top>
    <tr>
      <th align=left><code>SCWS_INVISIBLE</code></th>
      <td>0</td>
      <td>
      The normal display mode with white space displayed as an empty background colour.
      </td>
   </tr>
   <tr>
      <th align=left><code>SCWS_VISIBLEALWAYS</code></th>
      <td>1</td>
      <td>
      White space characters are drawn as dots and arrows,
      </td>
   </tr>
   <tr>
      <th align=left><code>SCWS_VISIBLEAFTERINDENT</code></th>
      <td>2</td>
      <td>
      White space used for indentation is displayed normally but after the first
      visible character, it is shown as dots and arrows.
      </td>
   </tr>
    </tbody>
  </table>
    <p>
    The effect of using any other wsMode value is undefined.
    </p>

    <p>
    <b id="SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE<(bool useWhitespaceForeColour,
                      int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool useWhitespaceBackColour,
                      int <a href="#colour">colour</a>)</b><br />
    By default, the colour of visible whitespace is determined by the lexer in use.  The
    foreground and / or background colour of all visible whitespace can be set globally,
    overriding the lexer's colours with <code>SCI_SETWHITESPACEFORE</code> and
    <code>SCI_SETWHITESPACEBACK</code>.
    </p>

<h2 id="Cursor">
   Cursor
</h2>
    <p>
    <b id="SCI_SETCURSOR">SCI_SETCURSOR(int curType)</b><br />
    <b id="SCI_GETCURSOR">SCI_GETCURSOR</b><br />
       The cursor is normally chosen in a context sensitive way, so it will be different over
       the margin than when over the text. When performing a slow action, you may wish to
       change to a wait cursor. You set the cursor type with <code>SCI_SETCURSOR</code>.
       The <code>curType</code> argument can be:
    </p>
  <table cellpadding="1" cellspacing="2" border="0">
   <tbody valign=top>
    <tr>
      <th align=left><code>SC_CURSORNORMAL</code></th>
      <td>-1</td>
      <td>
      The normal cursor is displayed.
      </td>
   </tr>
      <tr>
      <th align=left><code>SC_CURSORWAIT</code></th>
      <td>4</td>
      <td>
      The wait cursor is displayed when the mouse is over or owned by the Scintilla window.
      </td>
   </tr>
    </tbody>
  </table>
    <p>
    Cursor values 1 through 7 have defined cursors, but only <code>SC_CURSORWAIT</code> is usefully
    controllable. Other values of <code>curType</code> cause a pointer to be displayed. The
    <code>SCI_GETCURSOR</code> message returns the last cursor type you set, or
    <code>SC_CURSORNORMAL</code> (-1) if you have not set a cursor type.
    </p>

<h2 id="Mouse capture">
   Mouse capture
</h2>
    <p>
       <b id="SCI_SETMOUSEDOWNCAPTURES">SCI_SETMOUSEDOWNCAPTURES(bool captures)</b><br />
       <b id="SCI_GETMOUSEDOWNCAPTURES">SCI_GETMOUSEDOWNCAPTURES</b><br />
       When the mouse is pressed inside Scintilla, it is captured so future mouse movement
       events are sent to Scintilla. This behaviour may be turned off with
      <code>SCI_SETMOUSEDOWNCAPTURES(0)</code>.
    </p>

<h2 id="Line endings">
   Line endings
</h2>
    <p>
        Scintilla can interpret any of the three major line end conventions, Macintosh (\r), Unix
        (\n) and CP/M / DOS / Windows (\r\n). When the user presses the Enter key, one of these line
        end strings is inserted into the buffer. The default is \r\n, but this can be changed with
        the <code>SCI_SETEOLMODE</code> message. You can also convert the entire document to one
        of these line endings with <code>SCI_CONVERTEOLS</code>. Finally,
        you can choose to display the line
        endings with <code>SCI_SETVIEWEOL</code>.
    </p>
<pre>
<a href="#">SCI_SETEOLMODE(int eolMode)</a>
<a href="#">SCI_GETEOLMODE</a>
<a href="#">SCI_CONVERTEOLS(int eolMode)</a>
<a href="#">SCI_SETVIEWEOL(bool visible)</a>
<a href="#">SCI_GETVIEWEOL</a>
</pre>
    <p>
      <b id="SCI_SETEOLMODE">SCI_SETEOLMODE(int eolMode)</b><br />
      <b id="SCI_GETEOLMODE">SCI_GETEOLMODE</b><br />
      <code>SCI_SETEOLMODE</code> sets the characters that are added into the document when the user
      presses the Enter key. You can set eolMode to one of <code>SC_EOL_CRLF</code> (0),
      <code>SC_EOL_CR</code> (1), or <code>SC_EOL_LF</code> (2).
      The <code>SCI_GETEOLMODE</code> message retrieves the current state.
    </p>
    <p>
      <b id="SCI_CONVERTEOLS">SCI_CONVERTEOLS(int eolMode)</b><br />
      This message changes all the end of line characters in the document to match
      <code>eolMode</code>. Valid values are: <code>SC_EOL_CRLF</code> (0),
      <code>SC_EOL_CR</code> (1), or <code>SC_EOL_LF</code> (2).
    </p>
    <p>
      <b id="SCI_SETVIEWEOL">SCI_SETVIEWEOL(bool visible)</b><br />
      <b id="SCI_GETVIEWEOL">SCI_GETVIEWEOL</b><br />
      Normally, the end of line characters are hidden, but <code>SCI_SETVIEWEOL</code>
      allows you to display (or hide) them by setting <code>visible</code>
      <code>true</code> (or <code>false</code>). The visible rendering of the
      end of line characters is similar to (CR), (LF), or (CR)(LF).
      <code>SCI_GETVIEWEOL</code> returns the current state.
    </p>

<h2 id="Styling">
   Styling
</h2>
     <p>
     The styling messages allow you to assign styles to text. The standard Scintilla settings
     divide the 8 style bits available for each character into 5 bits (0 to 4 =
     <a href="#Style definition">styles 0 to 31</a>) that set a style and three
     bits (5 to 7) that define indicators. You can change the balance between styles
     and indicators with <a href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>.
     If your styling needs can be met by one of the standard lexers, or if you can write
     your own, then a lexer is probably the easiest way to style your document. If you choose
     to use the container to do the styling you can use the
     <a href="#SCI_SETLEXER"><code>SCI_SETLEXER</code></a> command to select
     <code>SCLEX_CONTAINER</code>, in which case the container is sent a
     <code>SCN_STYLENEEDED</code> <a href="#Notifications">notification</a> each
     time text needs styling for display. As another alternative, you might use idle time
     to style the document.Even if you use a lexer, you might use the styling commands
     to mark errors detected by a compiler. The following commands can be used.
     </p>
<pre>
<a href="#SCI_GETENDSTYLED">SCI_GETENDSTYLED</a>
<a href="#SCI_STARTSTYLING">SCI_STARTSTYLING(int position, int mask)</a>
<a href="#SCI_SETSTYLING">SCI_SETSTYLING(int length, int style)</a>
<a href="#SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int length, const char *styles)</a>
<a href="#SCI_SETLINESTATE">SCI_SETLINESTATE(int line, int value)</a>
<a href="#SCI_GETLINESTATE">SCI_GETLINESTATE(int line)</a>
<a href="#SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</a>
</pre>
    <p>
    <b id="SCI_GETENDSTYLED">SCI_GETENDSTYLED</b><br />
      Scintilla keeps a record of the last character that is likely to be styled correctly. This
      is moved forwards when characters after it are styled and moved backwards if changes are made
      to the text of the document before it. Before drawing text, this position is checked to see
      if any styling is needed and a notification message sent to the container if so. The
      container can send <code>SCI_GETENDSTYLED</code> to work out where it needs to start styling.
      Scintilla will always ask to style whole lines.
    </p>
    <p>
    <b id="SCI_STARTSTYLING">SCI_STARTSTYLING(int pos, int mask)</b><br />
      This prepares for styling by setting the styling position <code>pos</code> to start
      at and a <code>mask</code> indicating which bits of the style bytes can be set.
      The mask allows styling to occur over several passes, with, for example, basic
      styling done on an initial pass to ensure that the text of the code is seen
      quickly and correctly, and then a second slower pass, detecting syntax errors
      and using indicators to show where these are. For example, with the standard
      settings of 5 style bits and 3 indicator bits, you would use a <code>mask</code>
      value of 31 (0x1f) if you were setting text styles and did not want to change
      the indicators. After <code>SCI_STARTSTYLING</code>, send multiple
      <code>SCI_SETSTYLING</code> messages for each lexical entity to style.
    </p>
    <p>
    <b id="SCI_SETSTYLING">SCI_SETSTYLING(int length, int style)</b><br />
    This message sets the style of <code>length</code> characters starting at
    the styling position and then increases the styling position by <code>length</code>,
    ready for the next call.
    If <code>sCell</code> is the style byte, the operation is:<br />
    <code>if ((sCell & mask) != style) sCell = (sCell & ~mask) | style;</code><br />
    It is up to you to make sure that no bits in <code>style</code> are set that are clear
    in the <code>mask</code> or the result may not be what was intended.
    {Neil, surely you need a style &= mask; in CellBuffer::SetStyleFor and CellBuffer::SetStyleAt?}
    </p>
    <p>
    <b id="SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int length, const char *styles)</b><br />
    As an alternative to <code>SCI_SETSTYLING</code> which applies the same style to each byte,
    you can use this message which specifies the styles for each of <code>length</code> bytes
    from the styling position and then increases the styling position by <code>length</code>,
    ready for the next call. The <code>length</code> styling bytes pointed at by
     <code>styles</code> should not contain any bits not set in mask.
    </p>
    <p>
    <b id="SCI_SETLINESTATE">SCI_SETLINESTATE(int line, int value)</b><br />
    <b id="SCI_GETLINESTATE">SCI_GETLINESTATE(int line)</b><br />
    As well as the 8 bits of lexical state stored for each character there is also an integer stored
    for each line. This can be used for longer lived parse states such as what the current scripting
    language is in an ASP page. Use <code>SCI_SETLINESTATE</code> to set the integer value
    and <code>SCI_GETLINESTATE</code> to get the value.
    </p>
    <p>
    <b id="SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</b><br />
    This returns the last line that has any line state.
    </p>

<h2 id="Style definition">
   Style definition
</h2>
    <p>
    While the style setting messages mentioned above, change the style
    numbers associated with text, these messages define how those style
    numbers are interpreted visually.
    There are 128 lexer styles that can set, numbered 0 to <code>STYLEMAX</code> (127).
    Unless you use <a href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>
    to change the number of style bits, styles 0 to 31 are used to set the
    text attributes. There are also some predefined numbered styles
    starting at 32, The following <code>STYLE_</code>* constants are defined.
    </p>
   <table cellpadding="1" cellspacing="2" border="0">
   <tbody valign=top>
    <tr>
      <th align=left><code>STYLE_DEFAULT</code></th>
      <td>32</td>
      <td>
      This style defines the attributes that all styles receive when the
      <code>SCI_STYLECLEARALL</code> message is used.
      </td>
   </tr>
   <tr>
      <th align=left><code>STYLE_LINENUMBER</code></th>
      <td>33</td>
      <td>
      This style sets the attributes of the text used to display line numbers in
      a line number margin. The background colour set for this style also sets the
      background colour for all margins that do not have any folding mask bits set.
      That is, any margin for which <code>mask & SC_MASK_FOLDERS</code> is 0. See
      <a href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code><a/> for more about masks.
      </td>
   </tr>
   <tr>
      <th align=left><code>STYLE_BRACELIGHT</code></th>
      <td>34</td>
      <td>
      This style sets the attributes used when highlighting braces with the
      <a href="#Brace highlighting"><code>SCI_BRACEHIGHLIGHT</code></a> message
      and when highlighting the corresponding indentation with
      <a href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a>.
      </td>
   </tr>
   <tr>
      <th align=left><code>STYLE_BRACEBAD</code></th>
      <td>35</td>
      <td>
      This style sets the display attributes used when marking an unmatched
      brace with the <a href="#Brace highlighting"><code>SCI_BRACEBADLIGHT</code></a> message.
      </td>
    </tr>
   <tr>
      <th align=left><code>STYLE_CONTROLCHAR</code></th>
      <td>36</td>
      <td>
      This style sets the display attributes used when drawing control characters.
      See also: <a href="#SCI_SETCONTROLCHARSYMBOL"><code>SCI_SETCONTROLCHARSYMBOL</code></a>.
      </td>
    </tr>
   <tr>
      <th align=left><code>STYLE_INDENTGUIDE</code></th>
      <td>37</td>
      <td>
      This style sets the foreground and background colours used when drawing
      the indentation guides.
      </td>
    </tr>
   <tr>
      <th align=left><code>STYLE_LASTPREDEFINED</code></th>
      <td>39</td>
      <td>
      To make it easier for client code to discover the range of styles
      that are predefined, this is set to the style number of the last
      predefined style. {However, this is set to 39 and the last style with
      an indentifier is 37. Is this just to reserve space?}
      </td>
    </tr>
   <tr>
      <th align=left><code>STYLE_MAX</code></th>
      <td>127</td>
      <td>
      This is not a style but is the number of the maximum style that can
      be set. Styles between <code>STYLE_LASTPREDEFINED</code> and
      <code>STYLE_MAX</code> would be appropriate if you used
      <a href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>
      to set more than 5 style bits.
      </td>
    </tr>
    </tbody>
  </table>
    <p>
    For each style you can set the font name, size and use of bold, italic
    and underline, foreground and background colour and the character set.
    You can also choose to hide text with a given style, display all
    characters as upper or lower case and fill from the last character on
    a line to the end of the line (for embedded languages). There is also an
    experimental attribute to make text read-only.
    </p><p>
    It is entirely up to you how you use styles. If you want to use syntax
    colouring you might use style 0 for white space, style 1 for numbers,
    style 2 for keywords, style 3 for strings, style 4 for preprocessor,
    style 5 for operators, and so on.
    </p>

<pre>
<a href="#SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</a>
<a href="#SCI_STYLECLEARALL">SCI_STYLECLEARALL</a>
<a href="#SCI_STYLESETFONT">SCI_STYLESETFONT(int stylenumber, char *fontname)</a>
<a href="#SCI_STYLESETSIZE">SCI_STYLESETSIZE(int stylenumber, int sizeinpoints)</a>
<a href="#SCI_STYLESETBOLD">SCI_STYLESETBOLD(int stylenumber, bool bold)</a>
<a href="#SCI_STYLESETITALIC">SCI_STYLESETITALIC(int stylenumber, bool italic)</a>
<a href="#SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int stylenumber, bool underline)</a>
<a href="#SCI_STYLESETFORE">SCI_STYLESETFORE(int stylenumber, int colour)</a>
<a href="#SCI_STYLESETBACK">SCI_STYLESETBACK(int stylenumber, int colour)</a>
<a href="#SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int stylenumber, bool eolfilled)</a>
<a href="#SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int stylenumber, int charset)</a>
<a href="#SCI_STYLESETCASE">SCI_STYLESETCASE(int stylenumber, SC_CASE_MIXED or SC_CASE_UPPER or SC_CASE_LOWER)</a>
<a href="#SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int stylenumber, bool visible)</a>
<a href="#SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int stylenumber, bool changeable)</a>
</pre>
    <p>
    <b id="SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</b><br />
    This message resets <code>STYLE_DEFAULT</code> to its state when Scintilla
    was initialised.
    </p>
    <p>
    <b id="SCI_STYLECLEARALL">SCI_STYLECLEARALL</b><br />
    This message sets all styles to have the same attributes as <code>STYLE_DEFAULT</code>.
    If you are setting up Scintilla for syntax colouring, it is likely that
    the lexical styles you set will be very similar. One way to set the
    styles is to set <code>STYLE_DEFAULT</code> to the common features of all styles,
    use <code>SCI_STYLECLEARALL</code> to duplicate this, then make the calls needed to
    set the attributes that make your lexical styles different.
    </p>
    <p>
    <b id="SCI_STYLESETFONT">SCI_STYLESETFONT(int stylenumber, char *fontname)</b><br />
    <b id="SCI_STYLESETSIZE">SCI_STYLESETSIZE(int stylenumber, int sizeinpoints)</b><br />
    <b id="SCI_STYLESETBOLD">SCI_STYLESETBOLD(int stylenumber, bool bold)</b><br />
    <b id="SCI_STYLESETITALIC">SCI_STYLESETITALIC(int stylenumber, bool italic)</b><br />
    These messages (plus <a href="#SCI_STYLESETCHARACTERSET"><code>SCI_STYLESETCHARACTERSET</code></a>)
    set the font attributes that are used to match the fonts you request to
    those available. The <code>fontname</code> is a zero terminated string holding the name
    of a font. Under Windows, the name must be no more the 32 characters long
    and is not case sensitive. For internal cacheing, Scintilla tracks fonts by
    name and does care about the casing of font names, so please be consistent.
    {I believe you can crash Scintilla by using a font name in Windows of more
    than 32 characters as strcpy() is used to move the name into the LOGFONT}.
    </p>
    <p>
    <b id="SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int stylenumber, bool underline)</b><br />
    You can set a style to be underlined. The underline is drawn in the
    foreground colour. All characters with a style that includes the
    underline attribute are underlined, even if they are white space.
    </p>
    <p>
    <b id="SCI_STYLESETFORE">SCI_STYLESETFORE(int stylenumber, int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_STYLESETBACK">SCI_STYLESETBACK(int stylenumber, int <a href="#colour">colour</a>)</b><br />
    Text is drawn in the foreground colour, the space in each character that
    is not occupied by the character is drawn in the background colour.
    </p>
    <p>
    <b id="SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int stylenumber, bool eolfilled)</b><br />
    If the last character in the line has a style with this attribute set, the
    remainder of the line up to the right edge of the window is filled with the
    background colour set for the last character.
    This is useful when a document contains embedded sections in another
    language such as HTML pages with embedded JavaScript. By setting
    eolfilled true style and a consistent background colour (different from
    the background colour set for the HTML styles) to all JavaScript
    styles then JavaScript sections will be easily distinguished from HTML.
    </p>
    <p>
    <b id="SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int stylenumber, int charset)</b><br />
    You can set a style to use a different character set than the default.
    The places where such characters sets are likely to be useful are comments and
    literal strings. For example, <code>SCI_STYLESETCHARACTERSET(SCE_C_STRING,
    SC_CHARSET_RUSSIAN)</code> would ensure that strings in Russian would
    display correctly in C and C++ (<code>SCE_C_STRING</code> is the style number
    used by the C and C++ lexer to display literal strings; it has the value 6).
    This feature currently only works fully on Windows.
    </p>
    <p>
      The character sets supported on Windows are:</b><br />
    <code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_ARABIC</code>,
    <code>SC_CHARSET_BALTIC</code>, <code>SC_CHARSET_CHINESEBIG5</code>,
    <code>SC_CHARSET_DEFAULT</code>, <code>SC_CHARSET_EASTEUROPE</code>,
    <code>SC_CHARSET_GB2312</code>, <code>SC_CHARSET_GREEK</code>,
    <code>SC_CHARSET_HANGUL</code>, <code>SC_CHARSET_HEBREW</code>,
    <code>SC_CHARSET_JOHAB</code>, <code>SC_CHARSET_MAC</code>,
    <code>SC_CHARSET_OEM</code>, <code>SC_CHARSET_SHIFTJIS</code>,
    <code>SC_CHARSET_SYMBOL</code>, <code>SC_CHARSET_THAI</code>,
    <code>SC_CHARSET_TURKISH</code>, and <code>SC_CHARSET_VIETNAMESE</code>.
    </p>
    <p>
    The character sets supported on GTK+ are:</b><br />
    <code>SC_CHARSET_ANSI</code>,
    <code>SC_CHARSET_EASTEUROPE</code>, <code>SC_CHARSET_GB2312</code>,
    <code>SC_CHARSET_HANGUL</code>, and <code>SC_CHARSET_SHIFTJIS</code>.
    </p>
    <p>
    <b id="SCI_STYLESETCASE">SCI_STYLESETCASE(int stylenumber, int caseMode)</b><br />
    The value of caseMode determines how text is displayed. You can set
    upper case (<code>SC_CASE_UPPER</code>, 1) or lower case (<code>SC_CASE_LOWER</code>, 2)
    or display normally (<code>SC_CASE_MIXED</code>, 0). This does not change the
    stored text, only how it is displayed.
    </p>
    <p>
    <b id="SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int stylenumber, bool visible)</b><br />
    Text is normally visible. However, you can completely hide it by giving it
    a style with the <code>visible</code> set to 0. This could be used to hide embedded
    formatting instruction or hypertext keywords in HTML or XML.
    </p>
    <p>
    <b id="SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int stylenumber, bool changeable)</b><br />
    This is an experimental and incompletely implemented style attribute.
    The default setting is <code>changeable</code> set <code>true</code> but when
    set <code>false</code> it makes text read-only. Currently it only stops the
    caret from being within not-changeable text and does not yet stop deleting
    a range that contains not-changeable text.
    </p>

<h2 id="Caret and selection styles">
   Caret and selection styles
</h2>
    <p>
    The selection is shown by changing the foreground and/or background colours.
    If one of these is not set then that attribute is not changed for
    the selection. The default is to show the selection by changing the
    background to light grey and leaving the foreground the same as
    when it was not selected.
    When there is no selection, the current insertion point is marked by the
    text caret. This is a vertical line that is normally blinking on and off
    to attract the users attention.
    </p>
<pre>
<a href="#SCI_SETSELFORE">SCI_SETSELFORE(bool useSelectionForeColour, int colour)</a>
<a href="#SCI_SETSELBACK">SCI_SETSELBACK(bool useSelectionBackColour, int colour)</a>
<a href="#SCI_SETCARETFORE">SCI_SETCARETFORE(int colour)</a>
<a href="#SCI_GETCARETFORE">SCI_GETCARETFORE</a>
<a href="#SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool show)</a>
<a href="#SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</a>
<a href="#SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int colour)</a>
<a href="#SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</a>
<a href="#SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int milliseconds)</a>
<a href="#SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</a>
<a href="#SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int pixels)</a>
<a href="#SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</a>
<a href="#SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int symbol)</a>
<a href="#SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</a>
</pre>
    <p>
    <b id="SCI_SETSELFORE">SCI_SETSELFORE(bool useSelectionForeColour,
                                 int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_SETSELBACK">SCI_SETSELBACK(bool useSelectionBackColour,
                                 int <a href="#colour">colour</a>)</b><br />
    You can choose to override the default selection colouring with
    these two messages. The colour you provide is used if you set
    <code>useSelection*Colour</code> to <code>true</code>.
    If it is set to <code>false</code>, the default colour colouring is set.
    </p>
    <p>
    <b id="SCI_SETCARETFORE">SCI_SETCARETFORE(int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_GETCARETFORE">SCI_GETCARETFORE</b><br />
    The colour of the caret can be set with <code>SCI_SETCARETFORE</code> and retrieved with
    <code>SCI_CETCARETFORE</code>.
    </p>
    <p>
    <b id="SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool show)</b><br />
    <b id="SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</b><br />
    <b id="SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</b><br />
    You can choose to make the background colour of the line containing the caret
    different with these messages. To do this, set
    the desired background colour with <code>SCI_SETCARETLINEBACK</code>, then use
    <code>SCI_SETCARETLINEVISIBLE(true)</code> to enable the effect. You can cancel the
    effect with <code>SCI_SETCARETLINEVISIBLE(false)</code>. The two GET functions return the
    state and the colour. This form of background colouring has highest priority
    when a line has markers that would otherwise change the background colour.
    </p>
    <p>
    <b id="SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int milliseconds)</b><br />
    <b id="SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</b><br />
    The rate at which the caret blinks can be set with
    <code>SCI_SETCARETPERIOD</code> which determines the time in milliseconds that
    the caret is visible or invisible before changing state.
    Setting the period to 0 stops the caret blinking. The default value is
    500 milliseconds. <code>SCI_GETCARETPERIOD</code> returns the current setting.
    </p>
    <p>
    <b id="SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int pixels)</b><br />
    <b id="SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</b><br />
    The width of the caret can be set with <code>SCI_SETCARETWIDTH</code> to a value
    of 1, 2 or 3 pixels. The default width is 1 pixel. You can read back the
    current width with <code>SCI_GETCARETWIDTH</code>.
    </p>
    <p>
    <b id="SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int symbol)</b><br />
    <b id="SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</b><br />
    By default, Scintilla diplays control characters (characters with codes less
    than 32) as their ASCII mnemonics: "NUL", "SOH", "STX", "ETX", "EOT", "ENQ",
    "ACK", "BEL", "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1",
    "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS",
    "GS", "RS", "US" in a rounded rectangle. These mnemonics come from the
    early days of signalling, though some are still used (LF = Line Feed, BS
    = Back Space, CR = Carrige Return, for example).
    </p><p>
    You can choose to replace these mnemonics by a nominated symbol with an ASCII
    code in the range 32 to 255. If you set a symbol value less than 32, all control
    characters are displayed as mnemonics. The symbol you set is rendered in the the
    font of the style set for the character. You can read back the current symbol with
    the <code>SCI_GETCONTROLCHARSYMBOL</code> message. The default symbol value is 0.
    </p>

<h2 id="Margins">
   Margins
</h2>
    <p>
    There may be up to three margins to the left of the text display,
    plus a gap either side of the text. Each margin can be set to
    display either symbols or line numbers with
    <a href="#SCI_SETMARGINTYPEN"><code>SCI_SETMARGINTYPEN</code></a>.
    The markers that can be displayed in each margin are set with
    <a href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a>. Any
    markers not associated with a visible margin will be displayed as
    changes in background colour in the text.
    A width in pixels can be set for each margin. Margins with a zero
    width are ignored completely. You can choose if a mouse click in a margin
    sends a notification to the container or selects a line of text.
    </p><p>
    The margins are numbered 0 to 2. Using a margin number outside the
    valid range has no effect. By default, margin 0 is set to display
    line numbers, but is given a width of 0, so it is hidden. Margin 1 is
    set to display non-folding symbols and is given a width of 16 pixels,
    so it is visible. Margin 2 is set to diplay the folding symbols, but is
    given a width of 0, so it is hidden. Of course, you can set the margins
    to be whatever you wish.
    </p>
<pre>
<a href="#SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int margin, int type)</a>
<a href="#SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int margin)</a>
<a href="#SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int margin, int pixelwidth)</a>
<a href="#SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int margin)</a>
<a href="#SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int margin, int mask)</a>
<a href="#SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int margin)</a>
<a href="#SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int margin, bool sensitive)</a>
<a href="#SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int margin)</a>
<a href="#SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int pixels)</a>
<a href="#SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</a>
<a href="#SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixels)</a>
<a href="#SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</a>
</pre>
    <p>
    <b id="SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int margin, int iType)</b><br />
    <b id="SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int margin)</b><br />
    These two routines set and get the type of a margin. The margin argument
    should be 0, 1 or 2. You can use the predefined constants <code>SC_MARGIN_SYMBOL</code>
    (0) and <code>SC_MARGIN_NUMBER</code> (1) to set a margin as either a line number
    or a symbol margin. By convention, margin 0 is used for line numbers
    and the other two are used for symbols.
    </p>
    <p>
    <b id="SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int margin, int pixelwidth)</b><br />
    <b id="SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int margin)</b><br />
    These routines set and get the width of a margin in pixels. A margin with
    zero width is invisible. By default, Scintilla sets margin 1 for symbols with
    a width of 16 pixels, so this is a resonable guess if you are not sure what
    would be appropriate. Line number margins widths should take into account the
    number of lines in the document and the line number style. You could use
    something like <a href="#SCI_TEXTWIDTH"><code>SCI_TEXTWIDTH(STYLE_LINENUMBER, "_99999")</code></a>
    to get a suitable width.
    </p>
    <p>
    <b id="SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int margin, int mask)</b><br />
    <b id="SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int margin)</b><br />
    The mask is a 32-bit value. Each bit corresponds to one of 32 logical symbols that
    can be diplayed in a margin that is enabled for symbols. There is a useful
    constant, <code>SC_MASK_FOLDERS</code> (0xFE000000 or -33554432), that is
    a mask for the 7 logical symbols used to denote folding. You can assign a
    wide range of symbols and colours to each of the 32 logical symbols, see
    <a href="#Markers">Markers</a> for more information.
    If <code>(mask & SC_MASK_FOLDERS)==0</code>, the margin background
    colour is controlled by style 33 (<a href="#Style definition"><code>STYLE_LINENUMBER</code></a>).
    </p><p>
    You add logical markers to a line with <a href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>.
    If a line has an associated marker that does not not appear in the mask of
    any margin with a non-zero width, the marker changes the background colour of the line.
    For example, suppose you decide to use logical marker 10 to mark lines
    with a syntax error and you want to show such lines by changing the background
    colour. The mask for this marker is 1 shifted left 10 times (1<<10)
    which is 0x400. If you make sure that no symbol margin includes 0x400 in its mask,
    any line with the marker gets the background colour changed.
    </p><p>
    To set a non-folding margin 1 use <code>SCI_SETMARGINMASKN(1, ~SC_MASK_FOLDERS)</code>;
    to set a folding margin 2 use <code>SCI_SETMARGINMASKN(2, SC_MASK_FOLDERS)</code>. This
    is the default set by Scintilla.
    <code>~SC_MASK_FOLDERS</code> is 0x1FFFFFF in hexadecimal or 33554431 decimal. Of course,
    you may need to display all 32 symbols in a margin, in which case use
    <code>SCI_SETMARGINMASKN(margin, -1)</code>.
    </p>
    <p>
    <b id="SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int margin, bool sensitive)</b><br />
    <b id="SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int margin)</b><br />
    Each of the three margins can be set sensitive or insensitive to
    mouse clicks. A click in a sensitive margin sends a
    <a href="#Notifications"><code>SCN_MARGINCLICK</code> notification</a> to the container.
    Margins that are not sensitive act as selection margins which make it easy
    to select ranges of lines. By default, all margins are insensitive.
    </p>
    <p>
    <b id="SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int pixels)</b><br />
    <b id="SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</b><br />
    <b id="SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixels)</b><br />
    <b id="SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</b><br />
    These messages set and get the width of the blank margin on both sides of the
    text in pixels. The default is to one pixel on each side.
    </p>
<pre>
</pre>

<h2 id="Other settings">
   Other settings
</h2>
<pre>
<a href="#SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool allowPaletteUse)</a>
<a href="#SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</a>
<a href="#SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool isbuffered)</a>
<a href="#SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</a>
<a href="#SCI_SETCODEPAGE">SCI_SETCODEPAGE(int codepage)</a>
<a href="#SCI_GETCODEPAGE">SCI_GETCODEPAGE</a>
<a href="#SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, const char *chars)</a>
<a href="#SCI_GRABFOCUS">SCI_GRABFOCUS</a>
<a href="#SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</a>
<a href="#SCI_GETFOCUS">SCI_GETFOCUS</a>
</pre>
    <p>
    <b id="SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool allowPaletteUse)</b><br />
    <b id="SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</b><br />
    On 8 bit displays, which can only display a maximum of 256 colours,
    the graphics environment mediates between the colour needs of
    applications through the use of palettes. On GTK+, Scintilla always
    uses a palette.
    </p><p>
    On Windows, there are some problems with visual
    flashing when switching between applications with palettes and it
    is also necessary for the application containing the Scintilla
    control to forward some messages to Scintilla for its palette code
    to work. Because of this, by default, the palette is not used and
    the application must tell Scintilla to use one. If Scintilla is not
    using a palette it will only display in those colours already available,
    which are often the 20 Windows system colours.
    </p><p>
    To see an example of how to enable palette support in Scintilla,
    search the text of SciTE for <code>WM_PALETTECHANGED</code>,
    <code>WM_QUERYNEWPALETTE</code> and <code>SCI_SETUSEPALETTE</code>.
    The Windows messages to forward are:<br />
    <code>WM_SYSCOLORCHANGE</code>, <code>WM_PALETTECHANGED</code>,
    <code>WM_QUERYNEWPALETTE</code> (should return <code>TRUE</code>).
    </p><p>
    To forward a message <code>(WM_XXXX, WPARAM, LPARAM)</code> to Scintilla, you can use
    <code>SendMessage(hScintilla, WM_XXXX, WPARAM, LAPARAM)</code> where hScintilla is the
    handle to the Scintilla window you created as your editor.
    </p><p>
    While we are on the subject of forwarding messages in Windows, the top level
    window should forward any <code>WM_SETTINGCHANGE</code> messages to Scintilla (this is
    currently used to collect changes to mouse settings, but could be used for
    other user interface items in the future).
    </p>
    <p>
    <b id="SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool isbuffered)</b><br />
    <b id="SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</b><br />
    Turns on or off buffered drawing. Buffered drawing draws each line
    into a bitmap rather than directly to the screen and then copies
    the bitmap to the screen. This avoids flickering although it does
    take longer. The default is for drawing to be buffered.
    </p>
    <p>
    <b id="SCI_SETCODEPAGE">SCI_SETCODEPAGE(int codepage)</b><br />
    <b id="SCI_GETCODEPAGE">SCI_GETCODEPAGE</b><br />
    Scintilla has some very simple Japanese DBCS (and probably Chinese
    and Korean) support. Use this message with <code>codepage</code> set to the
    code page number to set Scintilla to use code page information to
    ensure double byte characters are treated as one character rather
    than two. This also stops the caret from moving between the two
    bytes in a double byte character. Call with <code>codepage</code>
    set to zero to disable DBCS support. The default is
    <code>SCI_SETCODEPAGE(0)</code>.
    </p><p>
    Code page <code>SC_CP_UTF8</code> (65001) sets Scintilla into
    Unicode mode with the document treated as a sequence of characters
    expressed in UTF-8. The text is converted to the platform's normal
    Unicode encoding before being
    drawn by the OS and can thus display Hebrew, Arabic, Cyrillic, and
    Han characters. Languages which can use two characters stacked
    vertically in one horizontal space such as Thai will mostly work
    but there are som eissues where the characters are drawn
    separately leading to visual glitches. Bidirectional text is not
    supported.
    </p><p>
    For GTK+, the locale should be set to a Unicode locale with a call similar to
    setlocale(LC_CTYPE, "en_US.UTF-8"). Fonts with an "iso10646" registry
    should be used in a font set. Font sets are a comma separated list of partial
    font specifications where each partial font specification can be in the form of
    foundry-fontface-charsetregistry-encoding *OR*
    fontface-charsetregistry-encoding *OR*
    foundry-fontface *OR*
    fontface. An example is "misc-fixed-iso10646-1,*".
    </p><p>
    {Setting code page to a non-zero value that is not <code>SC_CP_UTF8</code> causes...?}
    </p>
    <p>
    <b id="SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, const char *chars)</b><br />
    Scintilla has several functions that operate on words which are
    defined to be contiguous sequences of characters from a particular
    set of characters. This message defines which characters are
    members of that set. If <code>chars</code> is null then the default set,
    alphanumeric and '_', is used. For example, if you don't allow '_'
    in your set of characters use:<br />
    <code>SCI_SETWORDCHARS(0,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")</code>;
    {Neil - how about setting flags in the unused argument for upper alpha,
     lower alpha, and numberics - not everyone allows _, for example}.
    </p>
    <p>
    <b id="SCI_GRABFOCUS">SCI_GRABFOCUS</b><br />
    <b id="SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</b><br />
    <b id="SCI_GETFOCUS">SCI_GETFOCUS</b><br />
    On GTK+, focus handling is more complicated than on Windows,
    so Scintilla can be told with this message to grab the focus.
    </p>
    <p>
    The internal focus flag can be set with <code>SCI_SETFOCUS</code>.
    This is used by clients which have complex focus requirements such
    as having their own window which gets the real focus but with the
    need to indicate that Scintilla has the logical focus.
    </p>

<h2 id="Brace highlighting">
   Brace highlighting
</h2>
<pre>
<a href="#SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int pos1, int pos2)</a>
<a href="#SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int pos1)</a>
<a href="#SCI_BRACEMATCH">SCI_BRACEMATCH(int position, int maxReStyle)</a>
</pre>
    <p>
    <b id="SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int pos1, int pos2)</b><br />
    Up to two characters can be highlighted in a 'brace highlighting
    style' which is defined as
     <a href="#Style definition">style number <code>STYLE_BRACELIGHT</code></a> (34).
    If you have enabled indent guides you may also wish to highlight the
    indent that corresponds with the brace. You can locate the column
    with <a href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> and highlight
    the indent with
    <a href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a>.
    </p>
    <p>
    <b id="SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int pos1)</b><br />
    If there is no matching brace then the <a href="#Style definition">brace
    badlighting style</a>, style <code>BRACE_BADLIGHT</code> (35), can be used
    to show the brace that is unmatched. Using a position of
    <code>INVALID_POSITION</code> (-1) removes the highlight.
    </p>
    <p>
    <b id="SCI_BRACEMATCH">SCI_BRACEMATCH(int pos, int maxReStyle)</b><br />
    The <code>SCI_BRACEMATCH</code> message finds a corresponding matching brace
    given <code>pos</code>, the position of one brace. The brace characters handled are
    '(', ')', '[', ']', '{', '}', '&lt;', and '&gt;'. The search is forwards
    from an opening brace and backwards from a closing brace. If the
    character at position is not a brace character, or a matching
    brace cannot be found, the return value is -1. Otherwise, the
    return value is the position of the matching brace.
    </p><p>
    A match only occurs if the style of the matching brace is the same
    as the starting brace or the matching brace is beyond the end of
    styling. Nested braces are handled correctly. The <code>maxReStyle</code>
    parameter must currently be 0 - it may be used n the future to limit
    the length of brace searches.
    </p>

<h2 id"Tabs and Indentation Guides">
   Tabs and Indentation Guides
</h2>
    <p>
    Indentation (the white space at the start of a line) if often used
    by programmers to clarify program structure and in some languages, for
    example Python, it may be part of the language syntax. Tabs are
    normally used in editors to insert a tab character or to pad text
    with spaces up to the next tab.
    </p><p>
    Scintilla can be set to treat tab and backspace in the white space at
    the start of a line in a special way, so that inserting a tab indents
    the line to the next indent position rather than just inserting a tab
    at the current character position and backspace unindents the line rather
    than deleting a character. Scintilla can also display
    indentation guides (vertical lines) to help you to generate code.
    </p>
<pre>
<a href="#SCI_SETTABWIDTH">SCI_SETTABWIDTH(int widthinchars)</a>
<a href="#SCI_GETTABWIDTH">SCI_GETTABWIDTH</a>
<a href="#SCI_SETUSETABS">SCI_SETUSETABS(bool usetabs)</a>
<a href="#SCI_GETUSETABS">SCI_GETUSETABS</a>
<a href="#SCI_SETINDENT">SCI_SETINDENT(int widthinchars)</a>
<a href="#SCI_GETINDENT">SCI_GETINDENT</a>
<a href="#SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool tabIndents)</a>
<a href="#SCI_GETTABINDENTS">SCI_GETTABINDENTS</a>
<a href="#SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)</a>
<a href="#SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</a>
<a href="#SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int line, int indentation)</a>
<a href="#SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int line)</a>
<a href="#SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int line)</a>
<a href="#SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(bool view)</a>
<a href="#SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</a>
<a href="#SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int column)</a>
<a href="#SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</a>
</pre>
    <p>
    <b id="SCI_SETTABWIDTH">SCI_SETTABWIDTH(int widthinchars)</b><br />
    <b id="SCI_GETTABWIDTH">SCI_GETTABWIDTH</b><br />
    <code>SCI_SETTABWIDTH</code> sets the size of a tab as a multiple of the size
    of a space character in <code>STYLE_DEFAULT</code>. The default tab width is
    8 characters. There are no limits on tab sizes, but values less than 1
    or large values may have undesireable effects. {Neil - the doc previously
    said "in the style of the first style definition" but I don't think this
    is correct?}
    </p>
    <p>
    <b id="SCI_SETUSETABS">SCI_SETUSETABS(bool useTabs)</b><br />
    <b id="SCI_GETUSETABS">SCI_GETUSETABS</b><br />
    <code>SCI_SETUSETABS</code> determines whether indentation should be created out
    of a mixture of tabs and spaces or be based purely on spaces. Set
    <code>useTabs</code> to <code>false</code> (0) to create all tabs and indents out
    of spaces. The default is <code>true</code>. You can use
    <a href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a>
    to get the column of a position taking the width of a tab into account.
    </p>
    <b id="SCI_SETINDENT">SCI_SETINDENT(int widthInChars)</b><br />
    <b id="SCI_GETINDENT">SCI_GETINDENT</b><br />
    <code>SCI_SETINDENT</code> sets the size of indentation in terms of the width of
    a space in <a href="#Style definition"><code>STYLE_DEFAULT</code></a>. If you
    set a width of 0, the indent size is the same as the tab size. There are no
    limits on indent sizes, but values less than 0 or large values may have
    undesireable effects.
    </p>
    <p>
    <b id="SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool tabIndents)</b><br />
    <b id="SCI_GETTABINDENTS">SCI_GETTABINDENTS</b><br />
    <b id="SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)</b><br />
    <b id="SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</b><br />
    </p>
    <p>
    Inside indentation whitespace the tab and backspace keys can be
    made to indent and unindent rather than insert a tab character or
    delete a character with the <code>SCI_SETTABINDENTS</code> and
    <code>SCI_SETBACKSPACEUNINDENTS</code> functions.
    </p>
    <p>
    <b id="SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int line, int indentation)</b><br />
    <b id="SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int line)</b><br />
    The amount of indentation on a line can be discovered and set with
    <code>SCI_GETLINEINDENTATION</code> and <code>SCI_SETLINEINDENTATION</code>.
    The indentation is measured in character columns which correspond to the width of
    space characters.
    </p>
    <p>
    <b id="SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int line)</b><br />
    This returns the position at the end of indentation of a line.
    </p>
    <p>
    <b id="SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(bool view)</b><br />
    <b id="SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</b><br />
    Indentation guides are dotted vertical lines that appear within
    indentation whitespace every indent size columns. They make it
    easy to see which constructs line up especially when they extend
    over multiple pages.
    Style <a href="#Style definition"><code>STYLE_INDENTGUIDE</code></a>
    (37) is used to specify the foreground and background colour of the indentation guides.
    </p>
    <p>
    <b id="SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int column)</b><br />
    <b id="SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</b><br />
    When brace highlighting occurs, the indentation guide corresponding
    to the braces may be highlighted with the brace highlighting style,
    <a href="#Style definition"><code>STYLE_BRACELIGHT</code></a> (34).
    Set <code>column</code> to 0 to cancel this highlight.
    </p>

<h2 id="Markers">
Markers
</h2>
    <p>
    There are 32 markers, numbered 0 to 31, and you can assign any
    combination of them to each line in the document. Markers appear
    in the <a href="#Margins">selection margin</a> to the
    left of the text. If the selection margin is set to zero width, the
    background colour of the whole line is changed instead. Marker numbers 25 to 31
    are used by Scintilla in folding margins, and have symbolic names of the form
    <code>SC_MARKNUM_</code>*, for example <code>SC_MARKNUM_FOLDEROPEN</code>.
    </p><p>
    Marker numbers 0 to 24 have no pre-defined function; you can use
    them to mark syntax errors or the current point of execution, break
    points, or whatever you need marking. If you do not neeed folding,
    you can use all 32 for any purpose you wish.
    </p><p>
    Each marker number has a symbol associated with it. You can also set the
    foreground and background colour for each marker number, so you can use the
    same symbol more than once with different colouring for different uses.
    Scintilla has a set of symbols you can assign (<code>SC_MARK_</code>*) or you can use
    characters. By default, all 32 markers are set to <code>SC_MARK_CIRCLE</code> with
    a black foreground and a white background.
    </p><p>
    The markers are drawn in the order of their numbers, so higher numbered
    markers appear on top of lower numbered ones. Markers try to
    move with their text by tracking where the start of their line
    moves. When a line is deleted, its markers are combined, by an or
    operation, with the markers of the previous line.
    </p>
<pre>
<a href="#SCI_MARKERDEFINE">SCI_MARKERDEFINE(int markernumber, int markersymbols)</a>
<a href="#SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int markernumber, const char *xpm)</a>
<a href="#SCI_MARKERSETFORE">SCI_MARKERSETFORE(int markernumber, int colour)</a>
<a href="#SCI_MARKERSETBACK">SCI_MARKERSETBACK(int markernumber, int colour)</a>
<a href="#SCI_MARKERADD">SCI_MARKERADD(int line, int markernumber)</a>
<a href="#SCI_MARKERDELETE">SCI_MARKERDELETE(int line, int markernumber)</a>
<a href="#SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int markernumber)</a>
<a href="#SCI_MARKERGET">SCI_MARKERGET(int line)</a>
<a href="#SCI_MARKERNEXT">SCI_MARKERNEXT(int lineStart, int markermask)</a>
<a href="#SCI_MARKERPREVIOUS(">SCI_MARKERPREVIOUS(int lineStart, int markermask)</a>
<a href="#SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int handle)</a>
<a href="#SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int handle)</a>
</pre>
    <p>
    <b id="SCI_MARKERDEFINE">SCI_MARKERDEFINE(int markernumber, int markersymbols)</b><br />
    This message associates a marker number in the range 0 to 31 with one of
    the marker symbols or an ASCII character. The general-purpose marker symbols
    currently available are:<br />
    <code>SC_MARK_CIRCLE</code>, <code>SC_MARK_ROUNDRECT</code>,
    <code>SC_MARK_ARROW</code>, <code>SC_MARK_SMALLRECT</code>,
    <code>SC_MARK_SHORTARROW</code>, <code>SC_MARK_EMPTY</code>,
    <code>SC_MARK_ARROWDOWN</code>, <code>SC_MARK_MINUS</code>,
    <code>SC_MARK_PLUS</code>, <code>SC_MARK_ARROWS</code>,
    <code>SC_MARK_DOTDOTDOT</code>, <code>SC_MARK_EMPTY</code>
     and <code>SC_MARK_BACKGROUND</code>.
    </p><p>
    The <code>SC_MARK_BACKGROUND</code> marker changes the background colour of the line only.
    The <code>SC_MARK_EMPTY</code> symbol is invisible, allowing client code to track the movement
    of lines. You would also use it if you changed the folding style and wanted one or
    more of the <code>SC_FOLDERNUM_</code>* markers to have no associated symbol.
    </p><p>
    There are also marker symbols designed for use in the folding
    margin in a flattened tree style.
    <br />
    <code>SC_MARK_BOXMINUS</code>,
    <code>SC_MARK_BOXMINUSCONNECTED</code>,
    <code>SC_MARK_BOXPLUS</code>,
    <code>SC_MARK_BOXPLUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEMINUS</code>,
    <code>SC_MARK_CIRCLEMINUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEPLUS</code>,
    <code>SC_MARK_CIRCLEPLUSCONNECTED</code>,
    <code>SC_MARK_LCORNER</code>,
    <code>SC_MARK_LCORNERCURVE</code>,
    <code>SC_MARK_TCORNER</code>,
    <code>SC_MARK_TCORNERCURVE</code>, and
    <code>SC_MARK_VLINE</code>.
    </p></p>
    Characters can be used as markers by adding the ASCII value of the character
    to <code>SC_MARK_CHARACTER</code> (10000). For example, to use 'A' (ASCII code 65) as
    marker number 1 use:<br />
    <code>SCI_MARKETDEFINE(1, SC_MARK_CHARACETR+65)</code>.
    </p><p>
    The marker numbers <code>SC_MARKNUM_FOLDER</code> and <code>SC_MARKNUM_FOLDEROPEN</code> are
    used for showing that a fold is present and open or closed. Any
    symbols may be assigned for this purpose although the
    (<code>SC_MARK_PLUS</code>, <code>SC_MARK_MINUS</code>) pair or the (<code>SC_MARK_ARROW</code>,
    <code>SC_MARK_ARROWDOWN</code>) pair are good choices.
    As well as these two, more assignments are needed for the
    flattened tree style:
    <code>SC_MARKNUM_FOLDEREND</code>,
    <code>SC_MARKNUM_FOLDERMIDTAIL</code>,
    <code>SC_MARKNUM_FOLDEROPENMID</code>,
    <code>SC_MARKNUM_FOLDERSUB</code>, and
    <code>SC_MARKNUM_FOLDERTAIL</code>.
    The bits used for folding is specified by <code>SC_MASK_FOLDERS</code> which is
    commonly used as an argument to <code>SCI_SETMARGINMASKN</code> when defining a
    margin to be used for folding.
    </p><p>
    This table shows which <code>SC_MARK_</code>* symbols should be assigned to which
    <code>SC_MARKNUM_</code>* marker numbers to obtain four folding
    styles: Arrow (mimics Macintosh), plus/minus shows folded lines as
    '+' and opened folds as '-', Circle tree, Box tree.
    </p>
      <table cellpadding="1" cellspacing="2" border="0">
  <table>
   <thead align=left>
    <tr>
       <th><code>SC_MARKNUM_</code>*</th>
       <th>Arrow</th>
       <th>Plus/minus</th>
       <th>Circle tree</th>
       <th>Box tree</th>
    </tr>
   </thead>
   <tbody valign=top>
    <tr>
      <th align=left><code>FOLDEROPEN</code></th>
      <td><code>ARROWDOWN</code></td>
      <td><code>MINUS</code></td>
      <td><code>CIRCLEMINUS</code></td>
      <td><code>BOXMINUS</code></td>
   </tr>
    <tr>
      <th align=left><code>FOLDER</code></th>
      <td><code>ARROW</code></td>
      <td><code>PLUS</code></td>
      <td><code>CIRCLEPLUS</code></td>
      <td><code>BOXPLUS</code></td>
   </tr>
    <tr>
      <th align=left><code>FOLDERSUB</code></th>
      <td><code>EMPTY</code></td>
      <td><code>EMPTY</code></td>
      <td><code>VLINE</code></td>
      <td><code>VLINE</code></td>
   </tr>
    <tr>
      <th align=left><code>FOLDERTAIL</code></th>
      <td><code>EMPTY</code></td>
      <td><code>EMPTY</code></td>
      <td><code>LCORNERCURVE</code></td>
      <td><code>LCORNER</code></td>
   </tr>
    <tr>
      <th align=left><code>FOLDEREND</code></th>
      <td><code>EMPTY</code></td>
      <td><code>EMPTY</code></td>
      <td><code>CIRCLEPLUSCONNECTED</code></td>
      <td><code>BOXPLUSCONNECTED</code></td>
   </tr>
    <tr>
      <th align=left><code>FOLDEROPENMID</code></th>
      <td><code>EMPTY</code></td>
      <td><code>EMPTY</code></td>
      <td><code>CIRCLEMINUSCONNECTED</code></td>
      <td><code>BOXMINUSCONNECTED</code></td>
   </tr>
    <tr>
      <th align=left><code>FOLDERMIDTAIL</code></th>
      <td><code>EMPTY</code></td>
      <td><code>EMPTY</code></td>
      <td><code>TCORNERCURVE</code></td>
      <td><code>TCORNER</code></td>
   </tr>
    </tbody>
  </table>
    <p>
    <b id="SCI_MARKERSETFORE">SCI_MARKERSETFORE(int markernumber, int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_MARKERSETBACK">SCI_MARKERSETBACK(int markernumber, int <a href="#colour">colour</a>)</b><br />
    These two messages set the foreground and background colour of a
    marker number.
    </p>
    <p>
    <b id="SCI_MARKERADD">SCI_MARKERADD(int line, int markernumber)</b><br />
    This message adds marker number <code>markernumber</code> to a line. The messager
    returns -1 if this fails (illegal line number, out of memory) or it returns a marker handle number that
    identifies the added marker. You can use this returned handle with
    <a href="#SCI_MARKERLINEFROMHANDLE"><code>SCI_MARKERLINEFROMHANDLE</code></a> to find where a marker
    is after moving or combining lines and with
    <a href="#SCI_MARKERDELETEHANDLE"><code>SCI_MARKERDELETEHANDLE</code></a> to delete the marker based on
    its handle. The message does not check that the value of markernumber, nor does it
    check if the line already contains the marker.
    </p>
    <p>
    <b id="SCI_MARKERDELETE">SCI_MARKERDELETE(int line, int markernumber)</b><br />
    This searches the given line number for the given marker number and deletes it
    if it is present. If you added the same marker more than once to the line, this
    will delete one copy each time it is used. If you pass in a marker number of -1,
    all markers are deleted from the line.
    </p>
    <p>
    <b id="SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int markernumber)</b><br />
    This removes markers of the given number from all lines. If markernumber is -1, it
    deletes all markers from all lines.
    </p>
    <p>
    <b id="SCI_MARKERGET">SCI_MARKERGET(int line)</b><br />
    This returns a 32-bit integer that indicates which markers were present on the
    line. Bit 0 is set if marker 0 is present, bit 1 for marker 1 and so on.
    </p>
    <p>
    <b id="SCI_MARKERNEXT">SCI_MARKERNEXT(int lineStart, int markermask)</b><br />
    <b id="SCI_MARKERPREVIOUS">SCI_MARKERPREVIOUS(int lineStart, int markermask)</b><br />
    These messages search efficiently for lines that include a given set of markers.
    The search starts at line number <code>lineStart</code> and continues forwards
    to the end of the file (<code>SCI_MARKERNEXT</code>) or backwards to the start
    of the file (<code>SCI_MARKERPREVIOUS</code>).
    The <code>markermask</code> argument should have one bit set for each marker you
    wish to find. Set bit 0 to find marker 0, bit 1 for marker 1 and so on. The message
    returns the line number of the first line that contains one of the markers in
    <code>markermask</code> or -1 if no marker is found.
    </p>
    <p>
    <b id="SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int markerHandle)</b><br />
    The <code>markerHandle</code> argument is an identifier for a marker returned by
    <a href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. This function searches the
    document for the marker with this handle and returns the line number that contains it
    or -1 if it is not found.
    </p>
    <p>
    <b id="SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int markerHandle)</b><br />
    The <code>markerHandle</code> argument is an identifier for a marker returned by
    <a href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. This function searches the
    document for the marker with this handle and deletes the marker if it is found.
    </p>
    <p>
    <b id="SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int markernumber, const char *xpm)</b><br />
	Markers can be set to pixmaps using the SCI_MARKERDEFINEPIXMAP
	method. The XPM format is used for the pixmap and it is limited to
	to pixmaps that use one character per pixel. The data should be null terminated.
	Pixmaps use the SC_MARK_PIXMAP marker symbol.
    </p>


<h2 id="Indicators">
   Indicators
</h2>
    <p>
    By default, Scintilla organises the style byte associated with each text byte as
    5 bits of style information (for 32 styles) and 3 bits of indicator information
    for 3 independent indicators so that, for example, syntax errors, deprecated names
    and bad indentation could all be displayed at once. Indicators may be displayed
    as simple underlines, squiggly underlines, a line of small 'T' shapes, a line of
    diagonal hatching or as strike-out.
    </p><p>
    The indicators are set using
    <a href="#SCI_STARTSTYLING"><code>SCI_STARTSTYLING</code></a> with a
    <code>INDICS_MASK</code> mask and <a href="#SCI_SETSTYLING"><code>SCI_SETSTYLING</code></a>
    with the values <code>INDIC0_MASK</code>, <code>INDIC1_MASK</code> and <code>INDIC2_MASK</code>.
    </p><p>
    The number of bits used for styles can be altered with
    <a href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>
    from 0 to 7 bits. The remaining bits can be used for indicators, so there can be
    from 1 to 8 indicators. However, the <code>INDIC*_MASK</code> constants defined
    in scintilla.h all assume 5 bits of styling information and 3 indicators.
    If you use a different arrangement you must define your own constants.
    </p><p>
    The <code>SCI_INDIC*</code> messages allow you to get and set the visual appearance
    of the indicators. They all use an <code>indicatorNumber</code> argument in the range
    0 to 7 to set the indicator to style. With the default settings, only indicators 0, 1
    and 2 will have any visible effect.
    </p>

<pre>
<a href="#SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int indicatorNumber, int indicatorStyle)</a>
<a href="#SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</a>
<a href="#SCI_INDICSETFORE">SCI_INDICSETFORE(int indicatorNumber, int colour)</a>
<a href="#SCI_INDICGETFORE">SCI_INDICGETFORE(int indicatorNumber)</a>
</pre>
    <p>
    <b id="SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int indicatorNumber, int indicatorStyle)</b><br />
    <b id="SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</b><br />
    These two messages set and get the style for a particular indicator.
    The indicator styles currently available are:
   <table cellpadding="1" cellspacing="2" border="0">
   <thead>
   <tbody>
    <tr>
      <th align=left>Symbol</th>
      <th>Value</td>
      <th align=left>Visual effect</td>
   </tr>
   </thead>
   <tbody valign=top>
    <tr>
      <td align=left><code>INDIC_PLAIN</code></th>
      <td align=center>0</td>
      <td>Underlined with a single, straight line.</td>
   </tr>
   <tr>
      <td align=left><code>INDIC_SQUIGGLE</code></th>
      <td align=center>1</td>
      <td>A squiggly underline.</td>
   </tr>
   <tr>
      <td align=left><code>INDIC_TT</code></th>
      <td align=center>2</td>
      <td>A line of small T shapes.</td>
   </tr>
   <tr>
      <td align=left><code>INDIC_DIAGONAL</code></th>
      <td align=center>3</td>
      <td>Diagonal hatching.</td>
   </tr>
   <tr>
      <td align=left><code>INDIC_STRIKE</code></th>
      <td align=center>4</td>
      <td>Strike out.</td>
   </tr>
    </tbody>
  </table>
    </p><p>
    The default indicator styles are equivalent to:<br />
    <code>SCI_INDICSETSTYLE(0, INDIC_SQUIGGLE);</code><br />
    <code>SCI_INDICSETSTYLE(1, INDIC_TT);</code><br />
    <code>SCI_INDICSETSTYLE(2, INDIC_PLAIN);</code>
    </p>

    <p>
    <b id="SCI_INDICSETFORE">SCI_INDICSETFORE(int indicatorNumber, int <a href="#colour">colour</a>)</b><br />
    <b id="SCI_INDICGETFORE">SCI_INDICGETFORE(int indicatorNumber)</b><br />
    These two messages set and get the colour used to draw an indicator.
    The default indicator colours are equivalent to:<br />
    <code>SCI_INDICSETFORE(0, 0x007f00);</code> (dark green)<br />
    <code> SCI_INDICSETFORE(1, 0xff0000);</code> (light blue)<br />
    <code>SCI_INDICSETFORE(2, 0x0000ff);</code> (light red)
    </p>


<h2 id="Autocompletion">
   Autocompletion
</h2>
    <p>
    Autocompletion displays a list box showing likely identifiers,
    based upon the users typing. The user chooses the currently selected item
    by pressing the tab character or another character that is a member of
    the fillup character set defined with <code>SCI_AUTOCSETFILLUPS</code>.
    Autocompletion is triggered by your application. For example, in C if you
    detect that the user has just typed <code>fred.</code> you could look up
    <code>fred</code>, and if it has a known list of members, you could offer
    them in an autocompletion list. Alternatively, you could monitor the
    user's typing and offer a list of likely items once their typing has narrowed
    down the choice to a reasonable list. As yet another alternative you could
    define a key code to activate the list.
    </p><p>
    To make use of autocompletion you must monitor each character added to the
    document. See <code>SciTEBase::CharAdded()</code> in SciTEBase.cxx for an
    example of autocompletion.
    </p>
<pre>
<a href="#SCI_AUTOCSHOW">SCI_AUTOCSHOW(int lenEntered, const char *list)</a>
<a href="#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</a>
<a href="#SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</a>
<a href="#SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</a>
<a href="#SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</a>
<a href="#SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;,const char *chars)</a>
<a href="#SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char separator)</a>
<a href="#SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</a>
<a href="#SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;,const char *select)</a>
<a href="#SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool cancel)</a>
<a href="#SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</a>
<a href="#SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;,const char *chars)</a>
<a href="#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)</a>
<a href="#SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</a>
<a href="#SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool ignoreCase)</a>
<a href="#SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</a>
<a href="#SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool autoHide)</a>
<a href="#SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</a>
<a href="#SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)</a>
<a href="#SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</a>
</pre>
    <p>
    <b id="SCI_AUTOCSHOW">SCI_AUTOCSHOW(int lenEntered, const char *list)</b><br />
    This message causes a list to be displayed. <code>lenEntered</code> is the
    number of characters of the word already entered and <code>list</code>
    is the list of words separated by separator characters. The initial
    separator character is a space but this can be set or got with
    <a href="#SCI_AUTOCSETSEPARATOR"><code>SCI_AUTOCSETSEPARATOR</code></a> and
    <a href="#SCI_AUTOCGETSEPARATOR"><code>SCI_AUTOCGETSEPARATOR</code></a>.
    </p><p>
    The list of words should be in sorted order. If set to ignore case mode
    with <a href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a>,
    then strings are matched after being converted to upper case.
    One result of this is that the list should be sorted with the punctuation
    characters '[', '\', ']', '^', '_', and '`' sorted after letters.
    </p>
    <p>
    <b id="SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</b><br />
    This message cancels any displayed autocompletion list. When in
    autocompletion mode, the list should disappear when the user
    types a character that can not be part of the autocompletion,
    such as '.', '(' or '[' when typing an identifier. A set of
    characters which will cancel autocompletion can be specified
    with the <a href="#SCI_AUTOCSTOPS"><code>SCI_AUTOCSTOPS</code></a>.
    </p>
    <p>
    <b id="SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</b><br />
    This message returns non-zero if there is an active autocompletion list and zero
    if there is not.
    </p>
    <p>
    <b id="SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</b><br />
    This returns the value of the current position when
    <code>SCI_AUTOCSHOW</code> started display of the list.
    </p>
    <p>
    <b id="SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</b><br />
    This message triggers  message. This has the same effect as the tab key.
    </p>
    <p>
    <b id="SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;,const char *chars)</b><br />
    The <code>chars</code> argument is a string containing a list of characters that
    will automatically cancel the autocompletion list. When you start the editor,
    this list is empty.
    </p>
    <p>
    <b id="SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char separator)</b><br />
    <b id="SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</b><br />
    These two message set and get the separator character used to separate words
    in the <code>SCI_AUTOCSHOW</code> list. The default is the space character.
    </p>
    <p>
    <b id="SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;,const char *select)</b><br />
    This message selects an item in the autocompletion list. It searches the
    list of words for the first that matches <code>select</code>. By default,
    comparisons are case sensitive, but you can change this with
    <a href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a>.
    The match is character by character for the length of the <code>select</code> string.
    That is, if select is "Fred" it will match "Frederick" if this is the first item
    in the list that begins with "Fred". If an item is found, it is selected. If the
    item is not found, the autocompletion list closes if auto-hide is true (see
    <a href="#SCI_AUTOCSETAUTOHIDE"><code>SCI_AUTOCSETAUTOHIDE</code></a>).
    </p>
    <p>
    <b id="SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool cancel)</b><br />
    <b id="SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</b><br />
    The default behaviour is for the list to be cancelled if the caret
    moves before the location it was at when the list was displayed.
    By calling this message with a <code>false</code> argument, the
    list is not cancelled until the caret moves before the first
    character of the word being completed.
    </p>
    <p>
    <b id="SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;,const char *chars)</b><br />
    If a fillup character is typed with an autocompletion list active, the currently
    selected item in the list is added into the document, then the fillup character
    is added. Common fillup characters are '(', '[' and '.' but others are possible
    depending on the language. By default, no fillup characters are set.
    </p>
    <p>
    <b id="SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)</b><br />
    <b id="SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</b><br />
    If you use <code>SCI_AUTOCSETCHOOSESINGLE(1)</code> and a list has only
    one item, it is automatically added and no list is displayed. The default
    is to display the list even if there is only a single item.
    </p>
    <p>
    <b id="SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool ignoreCase)</b><br />
    <b id="SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</b><br />
    By default, matching of characters to list members is case sensitive. These
    messages let you set and get case sensitivity.
    </p>
    <p>
    <b id="SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool autoHide)</b><br />
    <b id="SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</b><br />
    By default, the list is cancelled if there are no viable matches (that is
    the user has typed characters that no longer match a list entry). If you
    want to keep displaying the original list, set <code>autoHide</code> to
    <code>false</code>. This also effects
    <a href="#SCI_AUTOCSELECT"><code>SCI_AUTOCSELECT</code></a>.
    </p>
    <p>
    <b id="SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)</b><br />
    <b id="SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</b><br />
    When an item is selected, any word characters following the caret are first
    erased if <code>dropRestOfWord</code> is set <code>true</code>. The default is
    <code>false</code>.
    </p>

<h2 id="User lists">
   User lists
</h2>
    <p>
    User lists use the internal mechanisms as autocompletion lists, and all the
    calls listed for autocompletion work on them; you cannot display a user list
    at the same time as an autocompletion list is active. They differ in the
    following respects:<br />
    o The <code>SCI_AUTOCSETCHOOSESINGLE</code> message has no effect.<br />
    o When the user makes a selection you are sent a <code>SCN_USERLISTSELECTION</code>
    <a href="#Notifications">notification message</a>.
    </p><p>
    BEWARE: if you have set fillup characters or stop characters, these will
    still be active with the user list, and may result in items being selected
    or the user list cancelled due to the user typing into the editor.
    </p>
    <p>
    <b id="">SCI_USERLISTSHOW(int listType, const char *list)</b><br />
    The <code>listType</code> parameter is returned to the container as
    the wParam field of the SCNotification structure. It must be greater
    than 0 (as this is how Scintilla tells the difference between an
    autocompletion list and a user list. If you have different types of
    list, for example a list of buffers and a list of macros, you can use
    <code>listType</code> to tell which one has returned a selection.
    </p>

<h2 id="Calltips">
   Calltips
</h2>
    <p>
    Call tips are small windows displaying the arguments to a function
    and are displayed after the user has typed the name of the
    function. There is some interaction between call tips and autocompletion
    lists in that showing a call tip cancels any active autocompletion
    list, and vice versa.
    </p><p>
    Call tips can highlight part of the text within them. You could use
    this to highlight the current argument to a function by counting the
    number of commas (or whatever separator your language uses).
    See <code>SciTEBase::CharAdded()</code> in SciTEBase.cxx for an
    example of call tip use.
    </p><p>
    Alternatively, call tips can be displayed when you leave the mouse
    pointer for a while over a word in response to the <code>SCN_DWELLSTART</code>
    <a href="#Notifications">notification</a> and cancelled in response
    to <code>SCN_DWELLEND</code>. This method could be used in a debugger to
    give the value of a variable, or during editing to give information about
    the word under the pointer.
    </p>
<pre>
<a href="#SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int posStart, const char *definition)</a>
<a href="#SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</a>
<a href="#SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</a>
<a href="#SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</a>
<a href="#SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int highlightstart, int highlightend)</a>
<a href="#SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int colour)</a>
</pre>
    <p>
    <b id="SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int posStart, const char *definition)</b><br />
    This message starts the process by displaying the call tip
    window. If a call tip is already active this has no effect.<br />
    <code>posStart</code> is the position in the document at which to
    align the call tip. The call tip text is aligned to start 1 line below
    this character.<br />
    <code>definition</code> is the call tip text. This can contain multiple
    lines separated by '\n' (Line Feed, ASCII code 10) characters.
    </p>
    <p>
    <b id="SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</b><br />
    This message cancels any displayed call tip. Scintilla will also cancel
    call tips for you if you use any keyboard commands that are not compatible
    with editing the argument list of a function.
    </p>
    <p>
    <b id="SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</b><br />
    This returns 1 if a call tip is active and 0 if it is not active.
    </p>
    <p>
    <b id="SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</b><br />
    This message returns the value of the current position
    when <code>SCI_CALLTIPSHOW</code> started to display the tip.
    </p>
    <p>
    <b id="SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int hlStart, int hlEnd)</b><br />
    This sets the region of the calltip text to display in a highlighted style.
    <code>hlStart</code> is the zero based index into the string of the first
    character to highlight and <code>hlEnd</code> is the index of the first
    character after the hightlight. <code>hlEnd</code> must be greater than
    <code>hlStart</code>; hlEnd-hlStart is the number of characters to
    highlight. Highlights can extend over line ends, if this is required.
    </p><p>
    Unhighlighted text is drawn in a mid grey. Selected text is
    drawn in a dark blue. The default background is white, but this
    can be changed with <code>SCI_CALLTIPSETBACK</code>. The only way to
    change the text colours is to edit the Scintilla source file
    <code>CallTip.cxx</code>.
    </p>
    <p>
    <b id="SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int colour)</b><br />
    The background colour of calltips can be set with this message;
    the default colour is white. It is not a good idea to set a dark
    colour as the background as the unselected text is drawn in mid grey
    and the selected text in a dark blue.
    </p>

<h2 id="Keyboard commands">
   Keyboard commands
</h2>
    <p>
    To allow the container application to perform any of the actions available to the
    user with keyboard, all the keyboard actions are messages. They do not take
    any parameters. These commands are also used when redefining the key bindings with
    the <a href="#SCI_ASSIGNCMDKEY"><code>SCI_ASSIGNCMDKEY</code></a> message.
    </p>

<table border="0">
<tbody>
  <tr>
    <td><code>SCI_LINEDOWN</code></td>
    <td><code>SCI_LINEDOWNEXTEND</code></td>
    <td><code>SCI_LINEUP</code></td>
    <td><code>SCI_LINEUPEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_CHARLEFT</code></td>
    <td><code>SCI_CHARLEFTEXTEND</code></td>
    <td><code>SCI_CHARRIGHT</code></td>
    <td><code>SCI_CHARRIGHTEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_WORDLEFT</code></td>
    <td><code>SCI_WORDLEFTEXTEND</code></td>
    <td><code>SCI_WORDRIGHT</code></td>
    <td><code>SCI_WORDRIGHTEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_HOME</code></td>
    <td><code>SCI_HOMEEXTEND</code></td>
    <td><code>SCI_LINEEND</code></td>
    <td><code>SCI_LINEENDEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_DOCUMENTSTART</code></td>
    <td><code>SCI_DOCUMENTSTARTEXTEND</code></td>
    <td><code>SCI_DOCUMENTEND</code></td>
    <td><code>SCI_DOCUMENTENDEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_PAGEUP</code></td>
    <td><code>SCI_PAGEUPEXTEND</code></td>
    <td><code>SCI_PAGEDOWN</code></td>
    <td><code>SCI_PAGEDOWNEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_EDITTOGGLEOVERTYPE</code></td>
    <td><code>SCI_CANCEL</code></td>
    <td><code>SCI_DELETEBACK</code></td>
    <td><code>SCI_DELETEBACKNOTLINE</code></td>
  </tr>
  <tr>
    <td><code>SCI_TAB</code></td>
    <td><code>SCI_BACKTAB</code></td>
    <td><code>SCI_NEWLINE</code></td>
    <td><code>SCI_FORMFEED</code></td>
  </tr>
  <tr>
    <td><code>SCI_VCHOME</code></td>
    <td><code>SCI_VCHOMEEXTEND</code></td>
    <td><code>SCI_DELWORDLEFT</code></td>
    <td><code>SCI_DELWORDRIGHT</code></td>
  </tr>
  <tr>
    <td><code>SCI_DELLINELEFT</code></td>
    <td><code>SCI_DELLINERIGHT</code></td>
    <td><code>SCI_LINESCROLLDOWN</code></td>
    <td><code>SCI_LINESCROLLUP</code></td>
  </tr>
  <tr>
    <td><code>SCI_LINECUT</code></td>
    <td><code>SCI_LINEDELETE</code></td>
    <td><code>SCI_LINETRANSPOSE</code></td>
    <td><code>SCI_LINEDUPLICATE</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SCI_LOWERCASE</code></td>
    <td><code>SCI_UPPERCASE</code></td>
    <td><code>SCI_WORDPARTLEFT</code></td>
    <td><code>SCI_WORDPARTLEFTEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_WORDPARTRIGHT</code></td>
    <td><code>SCI_WORDPARTRIGHTEXTEND</code></td>
    <td><code>SCI_HOMEDISPLAY</code></td>
    <td><code>SCI_HOMEDISPLAYEXTEND</code></td>
  </tr>
  <tr>
    <td><code>SCI_LINEENDDISPLAY</code></td>
    <td><code>SCI_LINEENDDISPLAYEXTEND</code></td>
    <td></td>
    <td></td>
  </tr>
</tbody>
</table>

    <p>
    The <code>SCI_*EXTEND</code> messages extend the selection.
    <p>
    The <code>SCI_WORDPART*</code> commands are used to move between word segments
    marked by capitalisation (aCamelCaseIdentifier) or underscores
    (an_under_bar_ident).
    </p>
    <p>
    The <code>SCI_[HOME|LINEEND]DISPLAY*</code> commands are used when
    in line wrap mode to allow movement to the start or end of display lines
    as opposed to the normal <code>[HOME|LINEEND]</code> commands which move
    to the start or end of document lines.
    </p>

<h2 id="Key bindings">
   Key bindings
</h2>
    <p>
    There is a default binding of keys to commands that is defined in the
    Scintilla source in the file <code>KeyMap.cxx</code> by the constant
    <code>KeyMap::MapDefault[]</code>. This table maps key definitions to
    SCI_* messages with no parameters (mostly the
    <a href="#Keyboard commands">keyboard commands</a> discussed above, but
    any Scintilla command that has no arguments can be mapped). You
    can change the mapping to suit your own requirements.
    </p>
<pre>
<a href="#SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int keyDefinition, int sciCommand)</a>
<a href="#SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int keyDefinition)</a>
<a href="#SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</a>
<a href="#SCI_NULL">SCI_NULL</a>
</pre>
    <p>
    <b id="keyDefinition">keyDefinition</b><br />
    A key definition contains the key code in the low 16-bits and the key modifiers
    in the high 16-bits. To combine keyCode and keyMod set:<br />
    <code>keyDefinition = keyCode + (keyMode << 16)</code>
    </p><p>
    The key code is a visible or control character or a key from the
    <code>SCK_*</code> enumeration, which contains:<br />
    <code>SCK_ADD</code>, <code>SCK_BACK</code>, <code>SCK_DELETE</code>, <code>SCK_DIVIDE</code>,
    <code>SCK_DOWN</code>, <code>SCK_END</code>, <code>SCK_ESCAPE</code>, <code>SCK_HOME</code>,
    <code>SCK_INSERT</code>, <code>SCK_LEFT</code>,
    <code>SCK_NEXT</code> (Page Down), <code>SCK_PRIOR</code> (Page Up),
    <code>SCK_RETURN</code>, <code>SCK_RIGHT</code>, <code>SCK_SUBTRACT</code>, <code>SCK_TAB</code>,
    and <code>SCK_UP</code>.
    </p><p>
    The modifiers are a combination of zero or more of
    <code>SCMOD_ALT</code>, <code>SCMOD_CTRL</code>, and <code>SCMOD_SHIFT</code>. If you
    are building a table you might want to use <code>SCMOD_NORM</code> which has
    the value 0, to mean no modifiers.
    </p>
    <p>
    <b id="SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int <a href="#keyDefinition">keyDefinition</a>, int sciCommand)</b><br />
    This assigns the given key definition to a Scintalla command identified
    by <code>sciCommand</code>. <code>sciCommand</code> can be any
    <code>SCI_*</code> command that has no arguments.
    </p>
    <p>
    <b id="SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int <a href="#keyDefinition">keyDefinition</a>)</b><br />
    This makes the given key definition do nothing by assigning the action <code>SCI_NULL</code> to it.
    </p>
    <p>
    <b id="SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</b><br />
    This command removes all keyboard command mapping by setting an empty mapping table.
    </p>
    <b id="SCI_NULL">SCI_NULL</b><br />
    The <code>SCI_NULL</code> does nothing and is the value assigned to keys that
    perform no action.
    </p>

<h2 id="Popup edit menu">
Popup edit menu
</h2>
    <p>
    <b id="SCI_USEPOPUP">SCI_USEPOPUP(bool bEnablePopup)</b><br />
    Clicking the wrong button on the mouse pops up a short default
    editing menu. This may be turned off with <code>SCI_USEPOPUP(0)</code>.
    </p>

<h2 id="Macro recording">
Macro recording
</h2>
    <p>
    Start and stop macro recording mode.
    In macro recording mode, actions are reported to the container through
    <code>SCN_MACRORECORD</code> <a href="#Notifications">notifications</a>.
    It is then up to the container to record these actions for future replay.
    </p>
    <p>
    <b id="SCI_STARTRECORD">SCI_STARTRECORD</b><br />
    <b id="SCI_STOPRECORD">SCI_STOPRECORD</b><br />
    These two messages turn macro recording on and off.
    </p>

<h2 id="Printing">
Printing
</h2>
<pre>
SCI_FORMATRANGE
SCI_SETPRINTMAGNIFICATION(int magnification)
SCI_GETPRINTMAGNIFICATION
SCI_SETPRINTCOLOURMODE(int mode)
SCI_GETPRINTCOLOURMODE
</pre>
    <p>
    On Windows SCI_FORMATRANGE can be used to draw the text onto a
    display context which can include a printer display context.
    </p>
    <p>
    To print at a different size than drawing on screen use
    SCI_SETPRINTMAGNIFICATION with a value which is the number of
    points to add to each style. -3 or -4 gives reasonable small print.
    </p>
    <p>
    If a black background is used on the screen then it is best to
    invert the light value of all colours with
    SCI_SETPRINTCOLOURMODE(SC_PRINT_INVERTLIGHT) when printing to give
    a white background.
    If intermediate tones are used on screen then black on white print
    can be chosen with SCI_SETPRINTCOLOURMODE(SC_PRINT_BLACKONWHITE).
    Other options are the default, SC_PRINT_NORMAL, and
    SC_PRINT_COLOURONWHITE and SC_PRINT_COLOURONWHITEDEFAULTBG.
    </p>

<h2 id="Direct access">
Direct access
</h2>
<pre>
SCI_GETDIRECTFUNCTION
SCI_GETDIRECTPOINTER
</pre>
    <p>
    On Windows, the message passing scheme used to communicate between
    the container and Scintilla is mediated by the operating system
    SendMessage function which can lead to bad performance when
    calling intensively.
    To avoid this overhead a pointer to a message handling function inside
    Scintilla can be retrieved with SCI_GETDIRECTFUNCTION.
    The first argument to use when calling the returned function is the
    value retrieved from SCI_GETDIRECTPOINTER. After that go the
    message number, wParam, and lParam.
    </p>
    <p>
    While faster, this direct calling will cause problems if performed
    from a different thread to the native thread of the Scintilla
    window in which case SendMessage should be used to synchronize with
    the window's thread.
    </p>
    <p>
    This feature also works on GTK+ but has no significant impact on
    speed.
    </p>
    <p>
    From version 1.47 on Windows, Scintilla exports a function called
    Scintilla_DirectFunction that can be used the same as the function returned by
    SCI_GETDIRECTFUNCTION.
    </p>

<h2 id="Multiple views">
Multiple views
</h2>
<pre>
SCI_GETDOCPOINTER
SCI_SETDOCPOINTER(&lt;unused&gt;,document *pdoc)
SCI_CREATEDOCUMENT
SCI_ADDREFDOCUMENT(&lt;unused&gt;,document *pdoc)
SCI_RELEASEDOCUMENT(&lt;unused&gt;,document *pdoc)
</pre>
    <p>
    This is to allow simple split views of documents and so
    applications may maintain multiple buffer which may be
    individually selected into the editor. Each Scintilla has a pointer
    to a used document.
    Initially the used document is a default one created when the
    Scintilla was created.
    The SCI_GETDOCPOINTER call returns a pointer to the used document.
    SCI_SETDOCPOINTER sets the used document.
    SCI_SETDOCPOINTER(0) switches to a new empty document.
    Before closing down Scintilla make sure all document pointers
    retrieved are released to avoid memory leaks.
    </p>
    <p>
    A new document may be created by SCI_CREATEDOCUMENT which returns a
    pointer to the document. This document is not selected into the
    editor and starts with a reference count of 1. A document may be
    released with SCI_RELEASEDOCUMENT and have its reference count
    incremented with SCI_ADDREFDOCUMENT.
    </p>

<h2 id="Folding">
Folding
</h2>
<pre>
SCI_VISIBLEFROMDOCLINE(int docLine)
SCI_DOCLINEFROMVISIBLE(int displayLine)
SCI_SETFOLDLEVEL(int line, int level)
SCI_SETFOLDFLAGS(int flags)
SCI_GETFOLDLEVEL(int line)
SCI_GETLASTCHILD(int line)
SCI_GETFOLDPARENT(int line)
SCI_SHOWLINES(int lineStart, int lineEnd)
SCI_HIDELINES(int lineStart, int lineEnd)
SCI_GETLINEVISIBLE(int line)
SCI_SETFOLDEXPANDED(int line, bool expanded)
SCI_GETFOLDEXPANDED(int line)
SCI_TOGGLEFOLD(int line)
SCI_ENSUREVISIBLE(int line)
SCI_ENSUREVISIBLEENFORCEPOLICY(int line)
</pre>
    <p>
    The fundamental operation in folding is making lines invisible or
    visible.
    Line visibility is a property of the view rather than the document
    so each view may be displaying a different set of lines.
    SCI_SHOWLINES and SCI_HIDELINES show or hide a range of lines.
    SCI_GETLINEVISIBLE determines whether a line is visible.
    When some lines are hidden, then a particular line in the document
    may be displayed at a different position to its document position.
    SCI_VISIBLEFROMDOCLINE and SCI_DOCLINEFROMVISIBLE map from
    document line to display line and back.
    </p>
    <p>
    Generally the fold points of a document are based on the
    hierarchical structure of the contents of the document.
    In Python, the hierarchy is determined by indentation and in C++
    by brace characters. This hierarchy can be represented within a
    Scintilla document object by attaching a numeric level to each
    line.
    The initial level of a file is SC_FOLDLEVELBASE to allow unsigned
    arithmetic on levels. The SC_FOLDLEVELNUMBERMASK constant can be
    used to mask out the other bits to reveal the fold level number.
    There are also two bit flags associated with each line.
    SC_FOLDLEVELWHITEFLAG indicates that the line is blank and allows
    it to be treated slightly different then its level may indicate.
    For example, blank lines should generally not be fold points.
    SC_FOLDLEVELHEADERFLAG indicates that the line is a header or fold
    point.
    </p>
    <p>
    The hierarchy can be navigated just through SCI_GETFOLDLEVEL, but
    it is often useful to find the parent of a line (SCI_GETFOLDPARENT)
    or the line that is the last child of a line (SCI_GETLASTCHILD).
    </p>
    <p>
    Each fold point may be either expanded, displaying all its child
    lines, or contracted, hiding all the child lines. This is per view
    state and can be manipulated with SCI_SETFOLDEXPANDED and
    SCI_GETFOLDEXPANDED. Using SCI_SETFOLDEXPANDED does not show or
    hide any lines but only changes a state flag and the margin markers
    that show the contraction state. SCI_TOGGLEFOLD performs the
    expansion or contraction of a fold point in the manner normally
    expected.
    </p>
    <p>
    A hidden line may be hidden because more than one of its parent
    lines is contracted. SCI_ENSUREVISIBLE travels up the fold
    hierarchy, expanding any contracted folds until it reaches the top
    level. The line will then be visible.
    </p>
    <p>
    The fold flags is a set of bit flags set with the SCI_SETFOLDFLAGS
    message to determine where folding lines are drawn. 2 is draw above
    if expanded, 4 is draw above if not expanded. 8 is draw below if
    expanded and 16 is draw below if not expanded.
    64 is display hexadecimal fold levels in line margin to aid debugging folding.
    This feature needs to be redesigned to be sensible.
    </p>

<h2 id="Line wrapping">
   Line wrapping
</h2>
<pre>
SCI_SETWRAPMODE(SC_WRAP_NONE or SC_WRAP_WORD)
SCI_GETWRAPMODE
</pre>
    <p>
    When the wrap mode is set to SC_WRAP_WORD lines wider than the
    window width are continued on the following lines. Lines are
    broken after space or tab characters or between runs of different
    styles. If this is not possible because a word in one style is
    wider than the window then the break occurs before after the last
    character that completely fits on the line.
    The horizontal scroll bar does not appear when wrap mode is on.
    </p>
<pre>
SCI_SETLAYOUTCACHE(SC_CACHE_NONE or SC_CACHE_CARET or SC_CACHE_PAGE or SC_CACHE_DOCUMENT)
SCI_GETLAYOUTCACHE
</pre>
    <p>
    Much of the time used by Scintilla is spent on laying out and drawing text.
    The same text layout calculations may be performed many times
    even when the data used in these calculations does not change.
    To avoid these unnecessary calculations in some circumstances, the line
    layout cache can store the results of the calculations.
    The cache in invalidated whenever the underlying data, such as the contents
    or styling of the document changes.
    Caching the layout of the whole document has the most effect, making dynamic
    line wrap as much as 20 times faster but this requires 7 times the memory
    required by the document contents.
    </p>
    <p>
    SC_CACHE_NONE performs no caching and is the default.
    SC_CACHE_CARET caches the layout information for the line containing the
    caret.
    SC_CACHE_PAGE caches the layout of the visible lines and the caret
    line.
    SC_CACHE_DOCUMENT caches the layout of the entire document.
    </p>

<h2 id="Zooming">
    Zooming
</h2>
<pre>
SCI_ZOOMIN
SCI_ZOOMOUT
SCI_SETZOOM
SCI_GETZOOM
</pre>
    <p>
    The text can be made larger and smaller by using SCI_ZOOMIN and
    SCI_ZOOMOUT.
    The zoom level can be retrieved by SCI_GETZOOM and set by
    SCI_SETZOOM.
    The zoom factors may range from -10 to + 20 and is added to each
    styles point size. The calculated point size never goes below 2.
    </p>

<h2 id="Long lines">
Long lines
</h2>
<pre>
SCI_GETEDGECOLUMN
SCI_SETEDGECOLUMN(int column)
SCI_GETEDGEMODE
SCI_SETEDGEMODE(int mode)
SCI_GETEDGECOLOUR
SCI_SETEDGECOLOUR(int colour)
</pre>
    <p>
    This mechanism marks lines that are longer than a specified length
    in one of two ways. A vertical line can be displayed at the
    specified column number (EDGE_LINE) or characters after that
    column can be displayed with a specified background colour
    (EDGE_BACKGROUND). The vertical line works well for monospaced
    fonts but not for proportional fonts which should use
    EDGE_BACKGROUND. The default is to not have any form of long line
    marking (EDGE_NONE).
    </p>

<h2 id="Lexer">
    Lexer
</h2>
<pre>
SCI_SETLEXER(int lexer)
SCI_SETLEXERLANGUAGE(&lt;unused&gt;, char *name)
SCI_GETLEXER
SCI_COLOURISE(int start, int end)
SCI_SETPROPERTY(char *key, char *value)
SCI_SETKEYWORDS(int keywordset, char *keywordlist)
</pre>
    <p>
    If the SciLexer version of Scintilla is used, then lexing support
    for some programming languages is included. A particular lexer may
    be chosen from the SCLEX* enumeration and it is invoked
    automatically to style the document as required. Lexers can also
    be chosen by string name rather than by integer ID.
    If the lexer is set to SCLEX_CONTAINER then the container is
    notified to perform styling as is the case with the standard
    Scintilla.DLL version. Styling may be requested for a range of the
    document by using SCI_COLOURISE.
    </p>
    <p>
    Settings can be communicated to the lexers using SCI_SETPROPERTY.
    Currently the "fold" property is defined for most of the lexers to
    set the fold structure if set to "1". SCLEX_PYTHON understands
    "tab.timmy.whinge.level" as a setting that determines how to
    indicate bad indentation. Many languages style a set of keywords
    distinctly from other words. Some languages, such as HTML may
    contain embedded languages, VBScript and Javascript are common for
    HTML. SCI_SETKEYWORDS specifies the keywords separated by spaces.
    For HTML, key word set 0 is for HTML, 1 is for Javascript and 2 is
    for VBScript.
    </p>

<h2 id="Notifications">
    Notifications
</h2>
    <p>
    Notifications are sent (fired) from the Scintilla control to its
    container when an event has occurred that may interest the
    container. Notifications are sent using the WM_NOTIFY message on
    Windows and the "notify" signal on GTK+ with a structure containing
    information about the event.
    </p>
<pre>
SCN_STYLENEEDED(int endstyleneeded)
</pre>
    <p>
    Before displaying a page or printing, this message is sent to the
    container. It is a good opportunity for the container to ensure
    that syntax styling information for the visible text.
    </p>
<pre>
SCN_UPDATEUI
SCN_CHECKBRACE
</pre>
    <p>
    Either the text or styling of the document has changed or the
    selection range has changed. Now would be a good time to update
    any container UI elements that depend on document or view state.
    Was previously called SCN_CHECKBRACE because a common use is to
    check whether the caret is next to a brace and set highlights on
    this brace and its corresponding matching brace.
    </p>
<pre>
SCN_CHARADDED(int charadded)
</pre>
    <p>
    Fired when the user types an ordinary text character (as opposed
    to a command character) which is entered into the text.
    Can be used by the container to decide to display a call tip or
    auto completion list.
    </p>
<pre>
SCN_SAVEPOINTREACHED
SCN_SAVEPOINTLEFT
</pre>
    <p>
    Sent to the container when the savepoint is entered or left,
    allowing the container to display a dirty indicator and change its
    menus.
    </p><p>
    See also: <a href="#SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</a>,
    <a href="#SCI_GETMODIFY">SCI_GETMODIFY</a>
    </p>
<pre>
SCN_MODIFYATTEMPTRO
</pre>
    <p>
    When in read-only mode, this notification is sent to the container
    should the user try to edit the document. This can be used to
    check the document out of a version control system.
    </p>
<pre>
SCN_DOUBLECLICK
</pre>
    <p>
    Mouse button was double clicked in editor.
    </p>
<pre>
SCN_KEY
</pre>
    <p>
    Reports all keys pressed. Used on GTK+ because of some problems
    with keyboard focus. Not sent by Windows version.
    </p>
<pre>
SCEN_SETFOCUS
SCEN_KILLFOCUS
</pre>
    <p>
    SCEN_SETFOCUS is fired when Scintilla receives focus and
    SCEN_KILLFOCUS when it loses focus.
    These notifications are sent using the WM_COMMAND message on
    Windows and the "Command" signal on GTK+ as this is the behaviour
    of the standard edit control.
    The SET and KILL values are flipped over from the Windows edit
    control and as clients depend on these constants, this will not be changed
    to be compatible.
    </p>
<pre>
SCN_MODIFIED
SCEN_CHANGE
SCI_SETMODEVENTMASK(int eventmask)
SCI_GETMODEVENTMASK
</pre>
    <p>
    SCN_MODIFIED is fired when the document has been changed including
    changes to both the text and styling. The notification structure
    contains information about what changed, how the change occurred
    and whether this changed the number of lines in the document. No
    modifications may be performed while in a SCN_MODIFIED event.
    </p>
    <p>
    SCEN_CHANGE is fired when the text of the document has been changed
    for any reason. This notification is sent using the WM_COMMAND
    message on Windows and the "Command" signal on GTK+ as this is the
    behaviour of the standard edit control.
    </p>
    <p>
    Both these notifications can be masked by the SCI_SETMODEVENTMASK
    function which sets which notification types are sent to the
    container. For example, a container may decide to see only
    notifications about changes to text and not styling changes by
    calling SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT).
    </p>
    <p>
    The possible notification types are
    SC_MOD_INSERTTEXT,
    SC_MOD_DELETETEXT,
    SC_MOD_CHANGESTYLE,
    SC_MOD_CHANGEFOLD,
    SC_PERFORMED_USER,
    SC_PERFORMED_UNDO,
    SC_PERFORMED_REDO,
    SC_LASTSTEPINUNDOREDO,
    SC_MOD_CHANGEMARKER,
    SC_MOD_BEFOREINSERT,
    SC_MOD_BEFOREDELETE, and
    SC_MODEVENTMASKALL.
    </p>
<pre>
SCN_MACRORECORD
</pre>
    <p>
    Tells the container that an operation is being performed so that
    the container may choose to record the fact if it is in a macro
    recording mode.
    The fields set in this notification are message, wParam, and lParam.
    </p>
<pre>
SCN_MARGINCLICK
</pre>
    <p>
    Tells the container that the mouse was clicked inside a margin
    marked sensitive. Can be used to perform folding or to place
    breakpoints.
    </p>
<pre>
SCN_NEEDSHOWN
</pre>
    <p>
    Scintilla has determined that a range of lines that is currently
    invisible should be made visible.
    An example of where this may be needed is if the end of line of a
    contracted fold point is deleted. This message is sent to the
    container in case it wants to make the line visible in some
    unusual way such as making the whole document visible.
    Most containers will just ensure each line in the range is
    visible by calling SCI_ENSUREVISIBLE.
    </p>
<pre>
SCN_PAINTED
</pre>
    <p>
    Painting has just been done. Useful when you want to update some
    other widgets based on a change in Scintilla, but want to have the
    paint occur first to appear more responsive.
    </p>
<pre>
SCN_USERLISTSELECTION
</pre>
    <p>
    User has selected an item in a user list.
    The list type is available in wParam and the text chosen in text.
    </p>
<pre>
SCN_URIDROPPED
</pre>
    <p>
    Only on the GTK+ version. Indicates that the user has dragged a URI
    such as a file name or web address onto Scintilla.
    The container could interpret this as a request to open the file.
    </p>
<pre>
SCN_DWELLSTART
SCN_DWELLEND
SCI_SETMOUSEDWELLTIME
SCI_GETMOUSEDWELLTIME
SC_TIME_FOREVER
</pre>
    <p>
    SCN_DWELLSTART is generated when the user hold the
    mouse still in one spot for the dwell period.
    SCN_DWELLEND is generated after a SCN_DWELLSTART
    and the mouse is moved or other activity such as key press
    indicates the dwell is over.
    </p>
    <p>
    The time the mouse must sit still, in milliseconds, to generate a
    SCN_DWELLSTART notification.
    If set to SC_TIME_FOREVER, the default, no dwell events will be
    generated.
    </p>
<pre>
SCN_ZOOM
</pre>
    <p>
    SCN_ZOOM is generated when the user zooms the display
    using the keyboard or the SCI_SETZOOM method is called.
    This notification can be used to recalculate positions, such as the
    width of the line number margin to maintain sizes in terms of characters
    rather than pixels.
    </p>

<h2 id="Deprecated messages">
Edit messages currently supported by Scintilla which will be
removed in the future.
</h2>
<pre>
WM_GETTEXT(int length, char *text)
WM_SETTEXT(&lt;unused&gt;, char *text)
EM_GETLINE(int line, char *text)
EM_REPLACESEL(&lt;unused&gt;, char *text)
EM_SETREADONLY
EM_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)
WM_CUT
WM_COPY
WM_PASTE
WM_CLEAR
WM_UNDO
EM_CANUNDO
EM_EMPTYUNDOBUFFER
WM_GETTEXTLENGTH
EM_GETFIRSTVISIBLELINE
EM_GETLINECOUNT
EM_GETMODIFY
EM_SETMODIFY(bool ismodified)
EM_GETRECT(RECT *rect)
EM_GETSEL(int *start, int *end)
EM_EXGETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_SETSEL(int start, int end)
EM_EXSETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_GETSELTEXT(&lt;unused&gt;, char *text)
EM_LINEFROMCHAR(int position)
EM_EXLINEFROMCHAR(int position)
EM_LINEINDEX(int line)
EM_LINELENGTH(int position)
EM_SCROLL(int line)
EM_LINESCROLL(int column, int line)
EM_SCROLLCARET()
EM_CANPASTE
EM_CHARFROMPOS(&lt;unused&gt;, POINT *location)
EM_POSFROMCHAR(int position, POINT *location)
EM_SELECTIONTYPE
EM_HIDESELECTION(bool hide)
EM_FINDTEXT(int flags, FINDTEXTEX *ft)
EM_FINDTEXTEX(int flags, FINDTEXTEX *ft)
EM_GETMARGINS
EM_SETMARGINS(EC_LEFTMARGIN or EC_RIGHTMARGIN or EC_USEFONTINFO, int val)
EM_FORMATRANGE
</pre>
<p>The SCN_POSCHANGED notification is also deprecated.</p>
<h2 id="Edit messages never supported by Scintilla">
   Edit messages never supported by Scintilla
</h2>
<pre>
EM_GETWORDBREAKPROC EM_GETWORDBREAKPROCEX
EM_SETWORDBREAKPROC EM_SETWORDBREAKPROCEX
EM_GETWORDWRAPMODE EM_SETWORDWRAPMODE
EM_LIMITTEXT EM_EXLIMITTEXT
EM_SETRECT EM_SETRECTNP
EM_FMTLINES
EM_GETHANDLE EM_SETHANDLE
EM_GETPASSWORDCHAR EM_SETPASSWORDCHAR
EM_SETTABSTOPS
EM_FINDWORDBREAK
EM_GETCHARFORMAT EM_SETCHARFORMAT
EM_GETOLEINTERFACE EM_SETOLEINTERFACE
EM_SETOLECALLBACK
EM_GETPARAFORMAT EM_SETPARAFORMAT
EM_PASTESPECIAL
EM_REQUESTRESIZE
EM_GETBKGNDCOLOR EM_SETBKGNDCOLOR
EM_STREAMIN EM_STREAMOUT
EM_GETIMECOLOR EM_SETIMECOLOR
EM_GETIMEOPTIONS EM_SETIMEOPTIONS
EM_GETOPTIONS EM_SETOPTIONS
EM_GETPUNCTUATION EM_SETPUNCTUATION
EM_GETTHUMB
EM_GETEVENTMASK
EM_SETEVENTMASK
EM_DISPLAYBAND
EM_SETTARGETDEVICE
</pre>
    <p>
    Scintilla tries to be a superset of the standard windows Edit and
    Richedit controls wherever that makes sense. As it is not
    intended for use in a word processor, some edit messages can
    not be sensibly handled. Unsupported messages have no effect.
    </p>

    <h2 id="Building Scintilla">
    Building Scintilla
    </h2>
    <p>
    To build Scintilla or SciTE, see the README file present in both
    the scintilla and scite directories. For Windows, GCC 2.95.3,
    Borland C++ or Microsoft Visual Studio .NET can be used for building.
    There is a make file for building Scintilla but not SciTE with
    Visual C++ 6 at scintilla/win32/scintilla_vc6.mak.
    For GTK+, GCC 2.95.2 should be used. GTK+ 1.2x and 2.0x are
    supported.
    Building for GTK+ 2.0x requires defining GTK2 on the command line.
    </p>
    <h3>
    Static linking
    </h3>
    <p>
    On Windows, Scintilla is normally used as a dynamic library as a .DLL file.
    If you want to link Scintilla directly into your application .EXE or .DLL file,
    then the STATIC_BUILD preprocessor symbol should be defined and
    Scintilla_RegisterClasses called. STATIC_BUILD prevents compiling the
    DllMain function which will conflict with any DllMain defined in your code.
    Scintilla_RegisterClasses takes the HINSTANCE of your application and
    ensures that the "Scintilla" window class is registered. To make sure that
    the right pointing arrow cursor used in the margin is displayed by Scintilla
    add the scintilla/win32/Margin.cur file to your application's resources with
    the ID IDC_MARGIN which is defined in scintilla/win32/platfromRes.h as 400.
    </p>
    <h3>
    Ensuring lexers are linked into Scintilla
    </h3>
    <p>
    Depending on the compiler and linker used, the lexers may be stripped
    out. This is most often caused when building a static library. To ensure
    the lexers are linked in, the Scintilla_LinkLexers() function may be
    called.
    </p>
    <h3>
    Changing set of lexers
    </h3>
    <p>
    To change the set of lexers in Scintilla, add and remove lexer source files
    (Lex*.cxx) from the scintilla/src directory and run the src/LexGen.py script
    from the src directory to update the make files and KeyWords.cxx.
    LexGen.py requires Python 2.1 or later.
    </p>
  </body>
</html>

